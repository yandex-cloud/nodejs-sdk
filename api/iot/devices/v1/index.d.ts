// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../../index.js';

import * as protobuf from '../../../../contrib/google/protobuf';
import * as operation from '../../../../api/operation';

/**
 * A device. For more information, see [Device](/docs/iot-core/concepts/index#device).
 */
export interface Device {
    /**
     * ID of the device.
     */
    id?: string;

    /**
     * ID of the registry that the device belongs to.
     */
    registryId?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the device. The name is unique within the registry.
     */
    name?: string;

    /**
     * Description of the device. 0-256 characters long.
     */
    description?: string;

    /**
     * Alias of a device topic.
     *
     * Alias is an alternate name of a device topic assigned by the user. Map alias to canonical topic name prefix, e.g. `my/custom/alias` match to `$device/abcdef/events`.
     */
    topicAliases?: { [s: string]: string };
}

/**
 * A device certificate. For more information, see [Managing device certificates](/docs/iot-core/operations/certificates/device-certificates).
 */
export interface DeviceCertificate {
    /**
     * ID of the device that the certificate belongs to.
     */
    deviceId?: string;

    /**
     * SHA256 hash of the certificate.
     */
    fingerprint?: string;

    /**
     * Public part of the certificate.
     */
    certificateData?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;
}

/**
 * A device password.
 */
export interface DevicePassword {
    /**
     * ID of the device that the password belongs to.
     */
    deviceId?: string;

    /**
     * ID of the password.
     */
    id?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;
}

/**
 * A set of methods to work with IoT Core messages on behalf of device
 */
export class DeviceDataService {
    constructor(session?: Session);
    /**
     * Publishes message on behalf of specified device
     */
    publish(
        request: PublishDeviceDataRequest
    ): Promise<PublishDeviceDataResponse>;
}

export interface PublishDeviceDataRequest {
    /**
     * ID of device publishing message
     */
    deviceId: string;

    /**
     * Topic where message should be published
     */
    topic: string;

    /**
     * Content of the message
     */
    data?: Buffer;
}

export interface PublishDeviceDataResponse {}

/**
 * A set of methods for managing devices.
 */
export class DeviceService {
    constructor(session?: Session);
    /**
     * Returns the specified device.
     *
     * To get the list of available devices, make a [List] request.
     */
    get(request: GetDeviceRequest): Promise<Device>;

    /**
     * Retrieves the list of devices in the specified registry.
     */
    list(request: ListDevicesRequest): Promise<ListDevicesResponse>;

    /**
     * Creates a device in the specified registry.
     */
    create(request: CreateDeviceRequest): Promise<operation.Operation>;

    /**
     * Updates the specified device.
     */
    update(request: UpdateDeviceRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified device.
     */
    delete(request: DeleteDeviceRequest): Promise<operation.Operation>;

    /**
     * Retrieves the list of device certificates for the specified device.
     */
    listCertificates(
        request: ListDeviceCertificatesRequest
    ): Promise<ListDeviceCertificatesResponse>;

    /**
     * Adds a certificate.
     */
    addCertificate(
        request: AddDeviceCertificateRequest
    ): Promise<operation.Operation>;

    /**
     * Deletes the specified device certificate.
     */
    deleteCertificate(
        request: DeleteDeviceCertificateRequest
    ): Promise<operation.Operation>;

    /**
     * Retrieves the list of passwords for the specified device.
     */
    listPasswords(
        request: ListDevicePasswordsRequest
    ): Promise<ListDevicePasswordsResponse>;

    /**
     * Adds password for the specified device.
     */
    addPassword(
        request: AddDevicePasswordRequest
    ): Promise<operation.Operation>;

    /**
     * Deletes the specified password.
     */
    deletePassword(
        request: DeleteDevicePasswordRequest
    ): Promise<operation.Operation>;

    /**
     * Lists operations for the specified device.
     */
    listOperations(
        request: ListDeviceOperationsRequest
    ): Promise<ListDeviceOperationsResponse>;
}

export interface GetDeviceRequest {
    /**
     * ID of the device to return.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;
}

export interface ListDevicesRequest {
    /**
     * ID of the registry to list devices in.
     *
     * To get a registry ID make a [yandex.cloud.iot.devices.v1.RegistryService.List] request.
     */
    registryId?: string;

    /**
     * ID of the folder to list devices in.
     *
     * To get a folder ID make a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId?: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than `page_size`, the service returns a [ListDevicesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListDevicesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListDevicesResponse {
    /**
     * List of devices.
     */
    devices?: Device[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListDevicesRequest.page_size], use `next_page_token` as the value
     * for the [ListDevicesRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateDeviceRequest {
    /**
     * ID of the registry to create a device in.
     *
     * To get a registry ID, make a [yandex.cloud.iot.devices.v1.RegistryService.List] request.
     */
    registryId: string;

    /**
     * Name of the device. The name must be unique within the registry.
     */
    name: string;

    /**
     * Description of the device.
     */
    description?: string;

    /**
     * Device certificate.
     */
    certificates?: CreateDeviceRequest.Certificate[];

    /**
     * Alias of a device topic.
     *
     * Alias is an alternate name of a device topic assigned by the user. Map alias to canonical topic name prefix, e.g. `my/custom/alias` match to `$device/{id}/events`.
     */
    topicAliases?: { [s: string]: string };

    /**
     * Device password.
     *
     * The password must contain at least three character categories among the following: upper case latin, lower case latin, numbers and special symbols.
     */
    password?: string;
}

export namespace CreateDeviceRequest {
    /**
     * Specification of a device certificate.
     */
    export interface Certificate {
        /**
         * Public part of the device certificate.
         */
        certificateData?: string;
    }
}

export interface CreateDeviceMetadata {
    /**
     * ID of the device that is being created.
     */
    deviceId?: string;
}

export interface UpdateDeviceRequest {
    /**
     * ID of the device to update.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * Field mask that specifies which fields of the device are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the device. The name must be unique within the registry.
     */
    name?: string;

    /**
     * Description of the device.
     */
    description?: string;

    /**
     * Alias of a device topic.
     *
     * Alias is an alternate name of a device topic assigned by the user. Map alias to canonical topic name prefix, e.g. `my/custom/alias` match to `$device/{id}/events`.
     */
    topicAliases?: { [s: string]: string };
}

export interface UpdateDeviceMetadata {
    /**
     * ID of the device that is being updated.
     */
    deviceId?: string;
}

export interface DeleteDeviceRequest {
    /**
     * ID of the device to delete.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;
}

export interface DeleteDeviceMetadata {
    /**
     * ID of the device that is being deleted.
     */
    deviceId?: string;
}

export interface ListDeviceCertificatesRequest {
    /**
     * ID of the device to list certificates for.
     */
    deviceId: string;
}

export interface ListDeviceCertificatesResponse {
    /**
     * List of certificates for the specified device.
     */
    certificates?: DeviceCertificate[];
}

export interface AddDeviceCertificateRequest {
    /**
     * ID of the device for which the certificate is being added.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * Public part of the certificate.
     */
    certificateData?: string;
}

export interface AddDeviceCertificateMetadata {
    /**
     * ID of the device certificate that is being added.
     */
    deviceId?: string;

    /**
     * Fingerprint of the certificate that is being added.
     */
    fingerprint?: string;
}

export interface DeleteDeviceCertificateRequest {
    /**
     * ID of the device to delete a certificate for.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * Fingerprint of the certificate to delete.
     */
    fingerprint: string;
}

export interface DeleteDeviceCertificateMetadata {
    /**
     * ID of the device certificate that is being deleted.
     */
    deviceId: string;

    /**
     * Fingerprint of the certificate that is being deleted.
     */
    fingerprint: string;
}

export interface ListDevicePasswordsRequest {
    /**
     * ID of the registry to list passwords in.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    deviceId: string;
}

export interface ListDevicePasswordsResponse {
    /**
     * List of passwords for the specified device.
     */
    passwords?: DevicePassword[];
}

export interface AddDevicePasswordRequest {
    /**
     * ID of the device to add a password for.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * Passwords for the device.
     *
     * The password must contain at least three character categories among the following: upper case latin, lower case latin, numbers and special symbols.
     */
    password?: string;
}

export interface AddDevicePasswordMetadata {
    /**
     * ID of the device for which the password is being added.
     */
    deviceId?: string;

    /**
     * ID of the password that is being added.
     */
    passwordId?: string;
}

export interface DeleteDevicePasswordRequest {
    /**
     * ID of the device to delete a password for.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * ID of the password to delete.
     *
     * To get a password ID make a [DeviceService.ListPasswords] request.
     */
    passwordId: string;
}

export interface DeleteDevicePasswordMetadata {
    /**
     * ID of the device for which the password is being deleted.
     */
    deviceId: string;

    /**
     * ID of the password that is being deleted.
     */
    passwordId: string;
}

export interface ListDeviceOperationsRequest {
    /**
     * ID of the device to list operations for.
     *
     * To get a device ID make a [DeviceService.List] request.
     */
    deviceId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than `page_size`, the service returns a [ListDeviceOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListDeviceOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on [Device.name] field.
     */
    filter?: string;
}

export interface ListDeviceOperationsResponse {
    /**
     * List of operations for the specified device certificate.
     */
    operations?: operation.Operation[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListDeviceOperationsRequest.page_size], use `next_page_token` as the value
     * for the [ListDeviceOperationsRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

/**
 * A registry. For more information, see [Registry](/docs/iot-core/concepts/index#registry).
 */
export interface Registry {
    /**
     * ID of the registry.
     */
    id?: string;

    /**
     * ID of the folder that the registry belongs to.
     */
    folderId?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the registry. The name is unique within the folder.
     */
    name?: string;

    /**
     * Description of the registry. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Ðœaximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * Status of the registry.
     */
    status?: Registry.Status;

    /**
     * ID of the logs group for the specified registry.
     */
    logGroupId?: string;
}

export namespace Registry {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Registry is being created.
         */
        CREATING = 1,

        /**
         * Registry is ready to use.
         */
        ACTIVE = 2,

        /**
         * Registry is being deleted.
         */
        DELETING = 3,
    }
}

/**
 * A registry certificate. For more information, see [Managing registry certificates](/docs/iot-core/operations/certificates/registry-certificates).
 */
export interface RegistryCertificate {
    /**
     * ID of the registry that the certificate belongs to.
     */
    registryId?: string;

    /**
     * SHA256 hash of the certificates.
     */
    fingerprint?: string;

    /**
     * Public part of the certificate.
     */
    certificateData?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;
}

/**
 * A device topic alias.
 *
 * Alias is an alternate name of a device topic assigned by the user. Map alias to canonical topic name prefix, e.g. `my/custom/alias` match to `$device/abcdef/events`. For more information, see [Using topic aliases](/docs/iot-core/concepts/topic#aliases).
 */
export interface DeviceAlias {
    /**
     * ID of the device that the alias belongs to.
     */
    deviceId?: string;

    /**
     * Prefix of a canonical topic name to be aliased, e.g. `$devices/abcdef`.
     */
    topicPrefix?: string;

    /**
     * Alias of a device topic.
     */
    alias?: string;
}

/**
 * A registry password.
 */
export interface RegistryPassword {
    /**
     * ID of the registry that the password belongs to.
     */
    registryId?: string;

    /**
     * ID of the password.
     */
    id?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;
}

/**
 * A set of methods to work with IoT Core messages on behalf of registry
 */
export class RegistryDataService {
    constructor(session?: Session);
    /**
     * Publishes message on behalf of specified registry
     */
    publish(
        request: PublishRegistryDataRequest
    ): Promise<PublishRegistryDataResponse>;
}

export interface PublishRegistryDataRequest {
    /**
     * ID of registry publishing message
     */
    registryId: string;

    /**
     * Topic where message should be published
     */
    topic: string;

    /**
     * Content of the message
     */
    data?: Buffer;
}

export interface PublishRegistryDataResponse {}

/**
 * A set of methods for managing registry.
 */
export class RegistryService {
    constructor(session?: Session);
    /**
     * Returns the specified registry.
     *
     * To get the list of available registries, make a [List] request.
     */
    get(request: GetRegistryRequest): Promise<Registry>;

    /**
     * Retrieves the list of registries in the specified folder.
     */
    list(request: ListRegistriesRequest): Promise<ListRegistriesResponse>;

    /**
     * Creates a registry in the specified folder.
     */
    create(request: CreateRegistryRequest): Promise<operation.Operation>;

    /**
     * Updates the specified registry.
     */
    update(request: UpdateRegistryRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified registry.
     */
    delete(request: DeleteRegistryRequest): Promise<operation.Operation>;

    /**
     * Retrieves the list of registry certificates for the specified registry.
     */
    listCertificates(
        request: ListRegistryCertificatesRequest
    ): Promise<ListRegistryCertificatesResponse>;

    /**
     * Adds a certificate.
     */
    addCertificate(
        request: AddRegistryCertificateRequest
    ): Promise<operation.Operation>;

    /**
     * Deletes the specified registry certificate.
     */
    deleteCertificate(
        request: DeleteRegistryCertificateRequest
    ): Promise<operation.Operation>;

    /**
     * Retrieves the list of passwords for the specified registry.
     */
    listPasswords(
        request: ListRegistryPasswordsRequest
    ): Promise<ListRegistryPasswordsResponse>;

    /**
     * Adds password for the specified registry.
     */
    addPassword(
        request: AddRegistryPasswordRequest
    ): Promise<operation.Operation>;

    /**
     * Deletes the specified password.
     */
    deletePassword(
        request: DeleteRegistryPasswordRequest
    ): Promise<operation.Operation>;

    /**
     * Retrieves the list of device topic aliases for the specified registry.
     */
    listDeviceTopicAliases(
        request: ListDeviceTopicAliasesRequest
    ): Promise<ListDeviceTopicAliasesResponse>;

    /**
     * Lists operations for the specified registry.
     */
    listOperations(
        request: ListRegistryOperationsRequest
    ): Promise<ListRegistryOperationsResponse>;
}

export interface GetRegistryRequest {
    /**
     * ID of the registry to return.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;
}

export interface ListRegistriesRequest {
    /**
     * ID of the folder to list registries in.
     *
     * To get a folder ID make a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than `page_size`, the service returns a [ListRegistriesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListRegistriesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListRegistriesResponse {
    /**
     * List of registries.
     */
    registries?: Registry[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListRegistriesRequest.page_size], use `next_page_token` as the value
     * for the [ListRegistriesRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateRegistryRequest {
    /**
     * ID of the folder to create a registry in.
     *
     * To get a folder ID, make a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the registry. The name must be unique within the folder.
     */
    name: string;

    /**
     * Description of the registry.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Registry certificates.
     */
    certificates?: CreateRegistryRequest.Certificate[];

    /**
     * Registry passwords.
     *
     * The password must contain at least three character categories among the following: upper case latin, lower case latin, numbers and special symbols.
     */
    password?: string;
}

export namespace CreateRegistryRequest {
    /**
     * Specification of a registry certificate.
     */
    export interface Certificate {
        /**
         * Public part of the registry certificate.
         */
        certificateData?: string;
    }
}

export interface CreateRegistryMetadata {
    /**
     * ID of the registry that is being created.
     */
    registryId?: string;
}

export interface UpdateRegistryRequest {
    /**
     * ID of the registry to update.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;

    /**
     * Field mask that specifies which fields of the registry are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the registry. The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the registry.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };
}

export interface UpdateRegistryMetadata {
    /**
     * ID of the registry that is being updated.
     */
    registryId?: string;
}

export interface DeleteRegistryRequest {
    /**
     * ID of the registry to delete.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;
}

export interface DeleteRegistryMetadata {
    /**
     * ID of the registry that is being deleted.
     */
    registryId?: string;
}

export interface ListRegistryCertificatesRequest {
    /**
     * ID of the registry to list certificates for.
     */
    registryId: string;
}

export interface ListRegistryCertificatesResponse {
    /**
     * List of certificates for the specified registry.
     */
    certificates?: RegistryCertificate[];
}

export interface AddRegistryCertificateRequest {
    /**
     * ID of the registry for which the certificate is being added.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;

    /**
     * Public part of the certificate that is being added.
     */
    certificateData?: string;
}

export interface AddRegistryCertificateMetadata {
    /**
     * ID of the registry certificate that is being added.
     */
    registryId?: string;

    /**
     * Fingerprint of the certificate that is being added.
     */
    fingerprint?: string;
}

export interface DeleteRegistryCertificateRequest {
    /**
     * ID of the registry to delete a certificate for.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;

    /**
     * Fingerprint of the certificate that is being deleted.
     */
    fingerprint: string;
}

export interface DeleteRegistryCertificateMetadata {
    /**
     * ID of a registry for which the certificate is being delete.
     */
    registryId: string;

    /**
     * Fingerprint of the certificate to deleted.
     */
    fingerprint: string;
}

export interface ListRegistryPasswordsRequest {
    /**
     * ID of the registry to list passwords in.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;
}

export interface ListRegistryPasswordsResponse {
    /**
     * List of passwords for the specified registry.
     */
    passwords?: RegistryPassword[];
}

export interface AddRegistryPasswordRequest {
    /**
     * ID of the registry to add a password for.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;

    /**
     * Passwords for the registry.
     *
     * The password must contain at least three character categories among the following: upper case latin, lower case latin, numbers and special symbols.
     */
    password?: string;
}

export interface AddRegistryPasswordMetadata {
    /**
     * ID of the registry for which the password is being added.
     */
    registryId?: string;

    /**
     * ID of a password that is being added.
     */
    passwordId?: string;
}

export interface DeleteRegistryPasswordRequest {
    /**
     * ID of the registry to delete a password for.
     *
     * To get a registry ID make a [DeviceService.List] request.
     */
    registryId: string;

    /**
     * ID of the password to delete.
     *
     * To get a password ID make a [RegistryService.ListPasswords] request.
     */
    passwordId: string;
}

export interface DeleteRegistryPasswordMetadata {
    /**
     * ID of a registry for which the password is being delete.
     */
    registryId: string;

    /**
     * ID of the password to delete.
     *
     * To get a password ID make a [RegistryService.ListPasswords] request.
     */
    passwordId: string;
}

export interface ListDeviceTopicAliasesRequest {
    /**
     * ID of the registry to list aliases for device topic.
     *
     * To get a registry ID make a [RegistryService.List] request.
     */
    registryId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than `page_size`, the service returns a [ListDeviceTopicAliasesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListDeviceTopicAliasesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListDeviceTopicAliasesResponse {
    /**
     * List of device aliases for the specified registry.
     */
    aliases?: DeviceAlias[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListDeviceTopicAliasesRequest.page_size], use `next_page_token` as the value
     * for the [ListDeviceTopicAliasesRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListRegistryOperationsRequest {
    /**
     * ID of the registry to list operations for.
     */
    registryId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than `page_size`, the service returns a [ListRegistryOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListRegistryOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on [Registry.name] field.
     */
    filter?: string;
}

export interface ListRegistryOperationsResponse {
    /**
     * List of operations for the specified registry.
     */
    operations?: operation.Operation[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListRegistryOperationsRequest.page_size], use `next_page_token` as the value
     * for the [ListRegistryOperationsRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}
