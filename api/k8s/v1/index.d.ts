// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../index.js';

import * as protobuf from '../../../contrib/google/protobuf';
import * as operation from '../../../api/operation';
import * as type from '../../../contrib/google/type';

/**
 * A Kubernetes cluster.
 */
export interface Cluster {
    /**
     * ID of the Kubernetes cluster.
     */
    id?: string;

    /**
     * ID of the folder that the Kubernetes cluster belongs to.
     */
    folderId?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the Kubernetes cluster.
     */
    name?: string;

    /**
     * Description of the Kubernetes cluster. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Мaximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * Status of the Kubernetes cluster.
     */
    status?: Cluster.Status;

    /**
     * Health of the Kubernetes cluster.
     */
    health?: Cluster.Health;

    /**
     * ID of the network the Kubernetes cluster belongs to.
     */
    networkId?: string;

    /**
     * Properties of the master for the Kubernetes cluster.
     */
    master?: Master;

    /**
     * Allocation policy for IP addresses of services and pods inside the Kubernetes cluster in different availability zones.
     */
    ipAllocationPolicy?: IPAllocationPolicy;

    /**
     * Gateway IPv4 address.
     */
    gatewayIpv4Address?: string;

    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster.
     */
    serviceAccountId?: string;

    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry or to push node logs and metrics.
     */
    nodeServiceAccountId?: string;

    /**
     * When creating a Kubernetes cluster, you should specify one of three release channels. The release channel contains several Kubernetes versions.
     * Channels differ in the set of available versions, the management of auto-updates, and the updates received.
     * You can't change the channel once the Kubernetes cluster is created, you can only recreate the Kubernetes cluster and specify a new release channel.
     * For more details see [documentation](https://cloud.yandex.com/docs/managed-kubernetes/concepts/release-channels-and-updates).
     */
    releaseChannel?: ReleaseChannel;

    networkPolicy?: NetworkPolicy;
}

export namespace Cluster {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Kubernetes cluster is waiting for resources to be allocated.
         */
        PROVISIONING = 1,

        /**
         * Kubernetes cluster is running.
         */
        RUNNING = 2,

        /**
         * Kubernetes cluster is being reconciled.
         */
        RECONCILING = 3,

        /**
         * Kubernetes cluster is being stopped.
         */
        STOPPING = 4,

        /**
         * Kubernetes cluster stopped.
         */
        STOPPED = 5,

        /**
         * Kubernetes cluster is being deleted.
         */
        DELETING = 6,

        /**
         * Kubernetes cluster is being started.
         */
        STARTING = 7,
    }

    export enum Health {
        HEALTH_UNSPECIFIED = 0,

        /**
         * Kubernetes cluster is alive and well.
         */
        HEALTHY = 1,

        /**
         * Kubernetes cluster is inoperable.
         */
        UNHEALTHY = 2,
    }
}

export enum ReleaseChannel {
    RELEASE_CHANNEL_UNSPECIFIED = 0,

    /**
     * Minor updates with new functions and improvements are often added.
     * You can't disable automatic updates in this channel, but you can specify a time period for automatic updates.
     */
    RAPID = 1,

    /**
     * New functions and improvements are added in chunks shortly after they appear on `RAPID`.
     */
    REGULAR = 2,

    /**
     * Only updates related to bug fixes or security improvements are added.
     */
    STABLE = 3,
}

export interface Master {
    /**
     * Parameters of the availability zone for the master.
     */
    zonalMaster?: ZonalMaster;

    /**
     * Parameters of the region for the master.
     */
    regionalMaster?: RegionalMaster;

    /**
     * Version of Kubernetes components that runs on the master.
     */
    version?: string;

    /**
     * Endpoints of the master. Endpoints constitute of scheme and port (i.e. `https://ip-address:port`)
     * and can be used by the clients to communicate with the Kubernetes API of the Kubernetes cluster.
     */
    endpoints?: MasterEndpoints;

    /**
     * Master authentication parameters are used to establish trust between the master and a client.
     */
    masterAuth?: MasterAuth;

    /**
     * Detailed information about the Kubernetes version that is running on the master.
     */
    versionInfo?: VersionInfo;

    /**
     * Maintenance policy of the master.
     */
    maintenancePolicy?: MasterMaintenancePolicy;
}

export interface MasterAuth {
    /**
     * PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
     */
    clusterCaCertificate?: string;
}

export interface ZonalMaster {
    /**
     * ID of the availability zone where the master resides.
     */
    zoneId?: string;

    /**
     * IPv4 internal network address that is assigned to the master.
     */
    internalV4Address?: string;

    /**
     * IPv4 external network address that is assigned to the master.
     */
    externalV4Address?: string;
}

export interface RegionalMaster {
    /**
     * ID of the region where the master resides.
     */
    regionId?: string;

    /**
     * IPv4 internal network address that is assigned to the master.
     */
    internalV4Address?: string;

    /**
     * IPv4 external network address that is assigned to the master.
     */
    externalV4Address?: string;
}

export interface MasterEndpoints {
    /**
     * Internal endpoint that can be used to connect to the master from cloud networks.
     */
    internalV4Endpoint?: string;

    /**
     * External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
     */
    externalV4Endpoint?: string;
}

export interface IPAllocationPolicy {
    /**
     * CIDR block. IP range for allocating pod addresses.
     *
     * It should not overlap with any subnet in the network the Kubernetes cluster located in. Static routes will be
     * set up for this CIDR blocks in node subnets.
     */
    clusterIpv4CidrBlock?: string;

    /**
     * Size of the masks that are assigned for each node in the cluster.
     *
     * If not specified, 24 is used.
     */
    nodeIpv4CidrMaskSize?: Long;

    /**
     * CIDR block. IP range Kubernetes service Kubernetes cluster IP addresses will be allocated from.
     *
     * It should not overlap with any subnet in the network the Kubernetes cluster located in.
     */
    serviceIpv4CidrBlock?: string;
}

export interface MasterMaintenancePolicy {
    /**
     * If set to true, automatic updates are installed in the specified period of time with no interaction from the user.
     * If set to false, automatic upgrades are disabled.
     */
    autoUpgrade?: boolean;

    /**
     * Maintenance window settings. Update will start at the specified time and last no more than the specified duration.
     * The time is set in UTC.
     */
    maintenanceWindow?: MaintenanceWindow;
}

export interface NetworkPolicy {
    provider?: NetworkPolicy.Provider;
}

export namespace NetworkPolicy {
    export enum Provider {
        PROVIDER_UNSPECIFIED = 0,

        CALICO = 1,
    }
}

/**
 * A set of methods for managing Kubernetes cluster.
 */
export class ClusterService {
    constructor(session?: Session);
    /**
     * Returns the specified Kubernetes cluster.
     *
     * To get the list of available Kubernetes cluster, make a [List] request.
     */
    get(request: GetClusterRequest): Promise<Cluster>;

    /**
     * Retrieves the list of Kubernetes cluster in the specified folder.
     */
    list(request: ListClustersRequest): Promise<ListClustersResponse>;

    /**
     * Creates a Kubernetes cluster in the specified folder.
     */
    create(request: CreateClusterRequest): Promise<operation.Operation>;

    /**
     * Updates the specified Kubernetes cluster.
     */
    update(request: UpdateClusterRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified Kubernetes cluster.
     */
    delete(request: DeleteClusterRequest): Promise<operation.Operation>;

    /**
     * Stops the specified Kubernetes cluster.
     */
    stop(request: StopClusterRequest): Promise<operation.Operation>;

    /**
     * Starts the specified Kubernetes cluster.
     */
    start(request: StartClusterRequest): Promise<operation.Operation>;

    /**
     * Lists nodegroup for the specified Kubernetes cluster.
     */
    listNodeGroups(
        request: ListClusterNodeGroupsRequest
    ): Promise<ListClusterNodeGroupsResponse>;

    /**
     * Lists operations for the specified Kubernetes cluster.
     */
    listOperations(
        request: ListClusterOperationsRequest
    ): Promise<ListClusterOperationsResponse>;

    /**
     * Lists cluster's nodes.
     */
    listNodes(
        request: ListClusterNodesRequest
    ): Promise<ListClusterNodesResponse>;
}

export interface GetClusterRequest {
    /**
     * ID of the Kubernetes cluster to return.
     */
    clusterId: string;
}

export interface ListClustersRequest {
    /**
     * ID of the folder to list Kubernetes cluster in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListClustersResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListClustersResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on [Cluster.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 1-61 characters long and match the regular expression `|[a-z][-a-z0-9]{1,61}[a-z0-9]`.
     */
    filter?: string;
}

export interface ListClustersResponse {
    /**
     * List of Kubernetes cluster.
     */
    clusters?: Cluster[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListClustersRequest.page_size], use
     * the `next_page_token` as the value
     * for the [ListClustersRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface DeleteClusterRequest {
    /**
     * ID of the Kubernetes cluster to delete.
     * To get Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;
}

export interface DeleteClusterMetadata {
    /**
     * ID of the Kubernetes cluster that is being deleted.
     */
    clusterId?: string;
}

export interface StopClusterRequest {
    /**
     * ID of the Kubernetes cluster to stop.
     * To get Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;

    /**
     * ID of the service account which has permission to stop the Kubernetes cluster.
     */
    serviceAccountId?: string;
}

export interface StopClusterMetadata {
    /**
     * ID of the Kubernetes cluster that is being stopped.
     */
    clusterId?: string;
}

export interface StartClusterRequest {
    /**
     * ID of the Kubernetes cluster to start.
     * To get Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;
}

export interface StartClusterMetadata {
    /**
     * ID of the Kubernetes cluster that is being started.
     */
    clusterId?: string;
}

export interface UpdateClusterRequest {
    /**
     * ID of the Kubernetes cluster to update.
     * To get the Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;

    updateMask?: protobuf.FieldMask;

    /**
     * Name of the Kubernetes cluster.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the Kubernetes cluster.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * Gateway IPv4 address.
     */
    gatewayIpv4Address?: string;

    /**
     * Specification of the master update.
     */
    masterSpec?: MasterUpdateSpec;

    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster.
     * Selected service account should have `edit` role on the folder where the Kubernetes cluster will be
     * located and on the folder where selected network resides.
     */
    serviceAccountId?: string;

    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry
     * or to push node logs and metrics.
     */
    nodeServiceAccountId?: string;

    networkPolicy?: NetworkPolicy;
}

export interface MasterUpdateSpec {
    /**
     * Specification of the master update.
     */
    version?: UpdateVersionSpec;

    /**
     * Maintenance policy of the master.
     */
    maintenancePolicy?: MasterMaintenancePolicy;
}

export interface UpdateClusterMetadata {
    /**
     * ID of the Kubernetes cluster that is being updated.
     */
    clusterId?: string;
}

export interface CreateClusterRequest {
    /**
     * ID of the folder to create a Kubernetes cluster in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the Kubernetes cluster.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the Kubernetes cluster.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the network.
     */
    networkId: string;

    /**
     * IP allocation policy of the Kubernetes cluster.
     */
    masterSpec: MasterSpec;

    /**
     * IP allocation policy of the Kubernetes cluster.
     */
    ipAllocationPolicy?: IPAllocationPolicy;

    /**
     * Gateway IPv4 address.
     */
    gatewayIpv4Address?: string;

    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster.
     * Selected service account should have `edit` role on the folder where the Kubernetes cluster will be
     * located and on the folder where selected network resides.
     */
    serviceAccountId: string;

    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry or to push node logs and metrics.
     */
    nodeServiceAccountId: string;

    /**
     * Release channel for the master.
     */
    releaseChannel?: ReleaseChannel;

    networkPolicy?: NetworkPolicy;
}

export interface CreateClusterMetadata {
    /**
     * ID of the Kubernetes cluster that is being created.
     */
    clusterId?: string;
}

export interface AutoUpgradeMasterMetadata {
    /**
     * ID of the Kubernetes cluster that is being auto upgraded.
     */
    clusterId?: string;
}

export interface ListClusterOperationsRequest {
    /**
     * ID of the Kubernetes cluster to list operations for.
     */
    clusterId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than [page_size], the service returns a [ListClusterOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListClusterOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on [Cluster.name] field.
     */
    filter?: string;
}

export interface ListClusterOperationsResponse {
    /**
     * List of operations for the specified Kubernetes cluster.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListClusterOperationsRequest.page_size], use the `next_page_token` as the value
     * for the [ListClusterOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListClusterNodeGroupsRequest {
    /**
     * ID of the Kubernetes cluster to list node groups in.
     * To get the Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListClusterNodeGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListClusterNodeGroupsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on [Cluster.name] field.
     */
    filter?: string;
}

export interface ListClusterNodeGroupsResponse {
    /**
     * List of node groups for the specified Kubernetes cluster.
     */
    nodeGroups?: NodeGroup[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListClusterNodeGroupsRequest.page_size], use
     * the `next_page_token` as the value
     * for the [ListClusterNodeGroupsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListClusterNodesRequest {
    /**
     * ID of the Kubernetes cluster to list nodes in.
     * To get the Kubernetes cluster ID use a [ClusterService.List] request.
     */
    clusterId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListClusterNodesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListClusterNodeGroupsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListClusterNodesResponse {
    /**
     * List of nodes for the specified Kubernetes cluster.
     */
    nodes?: Node[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListClusterNodesRequest.page_size], use
     * the `next_page_token` as the value
     * for the [ListClusterNodesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface MasterSpec {
    /**
     * Specification of the zonal master.
     */
    zonalMasterSpec?: ZonalMasterSpec;

    /**
     * Specification of the regional master.
     */
    regionalMasterSpec?: RegionalMasterSpec;

    /**
     * Version of Kubernetes components that runs on the master.
     */
    version?: string;

    /**
     * Maintenance policy of the master.
     */
    maintenancePolicy?: MasterMaintenancePolicy;
}

export interface ZonalMasterSpec {
    /**
     * ID of the availability zone.
     */
    zoneId: string;

    /**
     * Specification of parameters for internal IPv4 networking.
     */
    internalV4AddressSpec?: InternalAddressSpec;

    /**
     * Specification of parameters for external IPv4 networking.
     */
    externalV4AddressSpec?: ExternalAddressSpec;
}

export interface RegionalMasterSpec {
    /**
     * ID of the availability zone where the master resides.
     */
    regionId: string;

    /**
     * List of locations where the master will be allocated.
     */
    locations?: MasterLocation[];

    /**
     * Specify to allocate a static public IP for the master.
     */
    externalV4AddressSpec?: ExternalAddressSpec;
}

export interface InternalAddressSpec {
    /**
     * ID of the subnet. If no ID is specified, and there only one subnet in specified zone, an address in this subnet will be allocated.
     */
    subnetId?: string;
}

export interface ExternalAddressSpec {}

export interface MasterLocation {
    /**
     * ID of the availability zone.
     */
    zoneId: string;

    /**
     * If not specified and there is a single subnet in specified zone, address
     * in this subnet will be allocated.
     */
    internalV4AddressSpec?: InternalAddressSpec;
}

export interface MaintenanceWindow {
    /**
     * Updating the master at any time.
     */
    anytime?: AnytimeMaintenanceWindow;

    /**
     * Updating the master on any day during the specified time window.
     */
    dailyMaintenanceWindow?: DailyMaintenanceWindow;

    /**
     * Updating the master on selected days during the specified time window.
     */
    weeklyMaintenanceWindow?: WeeklyMaintenanceWindow;
}

export interface AnytimeMaintenanceWindow {}

export interface DailyMaintenanceWindow {
    /**
     * Window start time, in the UTC timezone.
     */
    startTime: type.TimeOfDay;

    /**
     * Window duration.
     */
    duration?: protobuf.Duration;
}

export interface DaysOfWeekMaintenanceWindow {
    /**
     * Days of the week when automatic updates are allowed.
     */
    days?: type.DayOfWeek[];

    /**
     * Window start time, in the UTC timezone.
     */
    startTime: type.TimeOfDay;

    /**
     * Window duration.
     */
    duration?: protobuf.Duration;
}

export interface WeeklyMaintenanceWindow {
    /**
     * Days of the week and the maintenance window for these days when automatic updates are allowed.
     */
    daysOfWeek?: DaysOfWeekMaintenanceWindow[];
}

export interface Node {
    /**
     * Computed node status.
     */
    status?: Node.Status;

    /**
     * Node specificaion.
     */
    spec?: Node.Spec;

    /**
     * Cloud instance status.
     * Not available in `MISSING` status.
     */
    cloudStatus?: Node.CloudStatus;

    /**
     * Kubernetes node status.
     * Not available in `PROVISIONING` and `NOT_CONNECTED` states.
     */
    kubernetesStatus?: Node.KubernetesStatus;
}

export namespace Node {
    /**
     * Kubernetes node info
     */
    export interface KubernetesStatus {
        /**
         * Node id (and instance name)
         */
        id?: string;

        /**
         * Conditions is an array of current observed node conditions.
         * More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
         */
        conditions?: Condition[];

        /**
         * If specified, the node's taints.
         */
        taints?: Taint[];

        /**
         * List of volumes that are attached to the node.
         */
        attachedVolumes?: AttachedVolume[];
    }

    /**
     * Cloud instance info
     */
    export interface CloudStatus {
        /**
         * Compute instance id
         */
        id?: string;

        /**
         * IG instance status
         */
        status?: string;

        /**
         * IG instance status message
         */
        statusMessage?: string;
    }

    /**
     * Computed node status.
     */
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Node instance is not yet created (e.g. in progress).
         */
        PROVISIONING = 1,

        /**
         * Node instance is created but not registered
         * (e.g. is still initializing).
         */
        NOT_CONNECTED = 2,

        /**
         * Node has connected but is not ready for
         * workload (see conditions for details).
         */
        NOT_READY = 3,

        /**
         * Node has connected and ready for workload.
         */
        READY = 4,

        /**
         * Node is still registered but its instance
         * is deleted (this is our bug).
         */
        MISSING = 5,
    }

    /**
     * Node specification.
     */
    export interface Spec {
        /**
         * Node group specified resources.
         */
        resources?: ResourcesSpec;

        /**
         * Node group specified disk.
         */
        disk?: DiskSpec;
    }
}

export interface Condition {
    /**
     * Type of node condition.
     */
    type?: string;

    /**
     * Status is the status of the condition.
     */
    status?: string;

    /**
     * Human-readable message indicating details about last transition.
     */
    message?: string;

    /**
     * Last time we got an update on a given condition.
     */
    lastHeartbeatTime?: protobuf.Timestamp;

    /**
     * Last time the condition transit from one status to another.
     */
    lastTransitionTime?: protobuf.Timestamp;
}

export interface Taint {
    /**
     * The taint key to be applied to a node.
     */
    key?: string;

    /**
     * The taint value corresponding to the taint key.
     */
    value?: string;

    /**
     * The effect of the taint on pods that do not tolerate the taint.
     */
    effect?: Taint.Effect;
}

export namespace Taint {
    export enum Effect {
        EFFECT_UNSPECIFIED = 0,

        /**
         * Do not allow new pods to schedule onto the node unless they tolerate the taint,
         * but allow all pods submitted to Kubelet without going through the scheduler
         * to start, and allow all already-running pods to continue running.
         */
        NO_SCHEDULE = 1,

        /**
         * Like NO_SCHEDULE, but the scheduler tries not to schedule
         * new pods onto the node, rather than prohibiting new pods from scheduling
         * onto the node entirely. Enforced by the scheduler.
         */
        PREFER_NO_SCHEDULE = 2,

        /**
         * Evict any already-running pods that do not tolerate the taint.
         */
        NO_EXECUTE = 3,
    }
}

/**
 * AttachedVolume describes a volume attached to a node
 */
export interface AttachedVolume {
    /**
     * Name of the driver which has attached the volume
     */
    driverName?: string;

    /**
     * Volume handle (cloud disk id)
     */
    volumeHandle?: string;
}

export interface NodeTemplate {
    /**
     * ID of the hardware platform configuration for the node.
     */
    platformId?: string;

    /**
     * Computing resources of the node such as the amount of memory and number of cores.
     */
    resourcesSpec?: ResourcesSpec;

    /**
     * Specification for the boot disk that will be attached to the node.
     */
    bootDiskSpec?: DiskSpec;

    /**
     * The metadata as `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
     *
     * For example, you may use the metadata in order to provide your public SSH key to the node.
     * For more information, see [Metadata](/docs/compute/concepts/vm-metadata).
     */
    metadata?: { [s: string]: string };

    /**
     * Specification for the create network interfaces for the node group compute instances.
     */
    v4AddressSpec?: NodeAddressSpec;

    /**
     * Scheduling policy configuration.
     */
    schedulingPolicy?: SchedulingPolicy;
}

export interface NodeAddressSpec {
    /**
     * One-to-one NAT configuration. Setting up one-to-one NAT ensures that public IP addresses are assigned to nodes, and therefore internet is accessible for all nodes of the node group. If the field is not set, NAT will not be set up.
     */
    oneToOneNatSpec?: OneToOneNatSpec;
}

export interface OneToOneNatSpec {
    /**
     * IP version for the public IP address.
     */
    ipVersion?: IpVersion;
}

export enum IpVersion {
    IP_VERSION_UNSPECIFIED = 0,

    /**
     * IPv4 address, for example 192.168.0.0.
     */
    IPV4 = 1,

    /**
     * IPv6 address, not available yet.
     */
    IPV6 = 2,
}

export interface ResourcesSpec {
    /**
     * Amount of memory available to the node, specified in bytes.
     */
    memory?: Long;

    /**
     * Number of cores available to the node.
     */
    cores?: Long;

    /**
     * Baseline level of CPU performance with the possibility to burst performance above that baseline level.
     * This field sets baseline performance for each core.
     */
    coreFraction?: Long;
}

export interface DiskSpec {
    /**
     * ID of the disk type.
     */
    diskTypeId?: string;

    /**
     * Size of the disk, specified in bytes.
     */
    diskSize?: Long;
}

export interface SchedulingPolicy {
    /**
     * True for preemptible compute instances. Default value is false. Preemptible compute instances are stopped at least once every 24 hours, and can be stopped at any time
     * if their resources are needed by Compute.
     * For more information, see [Preemptible Virtual Machines](/docs/compute/concepts/preemptible-vm).
     */
    preemptible?: boolean;
}

export interface NodeGroup {
    /**
     * ID of the node group.
     */
    id?: string;

    /**
     * ID of the cluster that the node group belongs to.
     */
    clusterId?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the node group.
     * The name is unique within the folder.
     */
    name?: string;

    /**
     * Description of the node group. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Мaximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * Status of the node group.
     */
    status?: NodeGroup.Status;

    /**
     * Node template that specifies parameters of the compute instances for the node group.
     */
    nodeTemplate?: NodeTemplate;

    /**
     * Scale policy of the node group.  For more information, see [Scaling policy](/docs/compute/concepts/instance-groups/policies#scale-policy).
     */
    scalePolicy?: ScalePolicy;

    /**
     * Allocation policy by which resources for node group are allocated to zones and regions.
     */
    allocationPolicy?: NodeGroupAllocationPolicy;

    /**
     * ID of the managed instance group associated with this node group.
     */
    instanceGroupId?: string;

    /**
     * Version of Kubernetes components that runs on the nodes.
     * Deprecated. Use version_info.current_version.
     */
    nodeVersion?: string;

    /**
     * Detailed information about the Kubernetes version that is running on the node.
     */
    versionInfo?: VersionInfo;

    /**
     * Maintenance policy of the node group.
     */
    maintenancePolicy?: NodeGroupMaintenancePolicy;

    /**
     * Support for unsafe sysctl parameters. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/).
     */
    allowedUnsafeSysctls?: string[];

    /**
     * Taints that are applied to the nodes of the node group at creation time.
     */
    nodeTaints?: Taint[];

    /**
     * Labels that are assigned to the nodes of the node group at creation time.
     */
    nodeLabels?: { [s: string]: string };
}

export namespace NodeGroup {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Node group is waiting for resources to be allocated.
         */
        PROVISIONING = 1,

        /**
         * Node group is running.
         */
        RUNNING = 2,

        /**
         * Node group is waiting for some work to be done, such as upgrading node software.
         */
        RECONCILING = 3,

        /**
         * Node group is being stopped.
         */
        STOPPING = 4,

        /**
         * Node group stopped.
         */
        STOPPED = 5,

        /**
         * Node group is being deleted.
         */
        DELETING = 6,

        /**
         * Node group is being started.
         */
        STARTING = 7,
    }
}

export interface ScalePolicy {
    /**
     * Fixed scale policy of the node group.
     */
    fixedScale?: ScalePolicy.FixedScale;

    /**
     * Auto scale policy of the node group.
     */
    autoScale?: ScalePolicy.AutoScale;
}

export namespace ScalePolicy {
    export interface FixedScale {
        /**
         * Number of nodes in the node group.
         */
        size?: Long;
    }

    export interface AutoScale {
        /**
         * Minimum number of nodes in the node group.
         */
        minSize?: Long;

        /**
         * Maximum number of nodes in the node group.
         */
        maxSize?: Long;

        /**
         * Initial number of nodes in the node group.
         */
        initialSize?: Long;
    }
}

export interface NodeGroupAllocationPolicy {
    /**
     * List of locations where resources for the node group will be allocated.
     */
    locations?: NodeGroupLocation[];
}

export interface NodeGroupLocation {
    /**
     * ID of the availability zone where the nodes may reside.
     */
    zoneId: string;

    /**
     * ID of the subnet. If a network chosen for the Kubernetes cluster has only one subnet in the specified zone, subnet ID may be omitted.
     */
    subnetId?: string;
}

export interface NodeGroupMaintenancePolicy {
    /**
     * If set to true, automatic updates are installed in the specified period of time with no interaction from the user.
     * If set to false, automatic upgrades are disabled.
     */
    autoUpgrade?: boolean;

    /**
     * If set to true, automatic repairs are enabled. Default value is false.
     */
    autoRepair?: boolean;

    /**
     * Maintenance window settings. Update will start at the specified time and last no more than the specified duration.
     * The time is set in UTC.
     */
    maintenanceWindow?: MaintenanceWindow;
}

/**
 * A set of methods for managing node groups.
 */
export class NodeGroupService {
    constructor(session?: Session);
    /**
     * Returns the specified node group.
     *
     * To get the list of available node group, make a [List] request.
     */
    get(request: GetNodeGroupRequest): Promise<NodeGroup>;

    /**
     * Retrieves the list of node group in the specified Kubernetes cluster.
     */
    list(request: ListNodeGroupsRequest): Promise<ListNodeGroupsResponse>;

    /**
     * Creates a node group in the specified Kubernetes cluster.
     */
    create(request: CreateNodeGroupRequest): Promise<operation.Operation>;

    /**
     * Updates the specified node group.
     */
    update(request: UpdateNodeGroupRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified node group.
     */
    delete(request: DeleteNodeGroupRequest): Promise<operation.Operation>;

    /**
     * Lists operations for the specified node group.
     */
    listOperations(
        request: ListNodeGroupOperationsRequest
    ): Promise<ListNodeGroupOperationsResponse>;

    /**
     * Retrieves the list of nodes in the specified Kubernetes cluster.
     */
    listNodes(
        request: ListNodeGroupNodesRequest
    ): Promise<ListNodeGroupNodesResponse>;
}

export interface GetNodeGroupRequest {
    /**
     * ID of the node group to return.
     * To get the node group ID use a [NodeGroupService.List] request.
     */
    nodeGroupId: string;
}

export interface ListNodeGroupsRequest {
    /**
     * ID of the folder to list node groups in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListNodeGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListNodeGroupsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on [NodeGroup.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 1-61 characters long and match the regular expression `|[a-z][-a-z0-9]{1,61}[a-z0-9]`.
     */
    filter?: string;
}

export interface ListNodeGroupsResponse {
    /**
     * List of node groups.
     */
    nodeGroups?: NodeGroup[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListNodeGroupsRequest.page_size], use
     * the `next_page_token` as the value
     * for the [ListNodeGroupsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListNodeGroupNodesRequest {
    /**
     * ID of the node group to list.
     * To get the node group ID use a [NodeGroupService.List] request.
     */
    nodeGroupId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListNodeGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListNodeGroupNodessResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListNodeGroupNodesResponse {
    /**
     * List of nodes.
     */
    nodes?: Node[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListNodeGroupNodesRequest.page_size], use
     * the `next_page_token` as the value
     * for the [ListNodeGroupNodesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface DeleteNodeGroupRequest {
    /**
     * ID of the node group to delete.
     * To get node group ID use a [NodeGroupService.List] request.
     */
    nodeGroupId: string;
}

export interface DeleteNodeGroupMetadata {
    /**
     * ID of the node group that is being deleted.
     */
    nodeGroupId?: string;
}

export interface UpdateNodeGroupRequest {
    /**
     * ID of the node group to update.
     * To get the node group ID use a [NodeGroupService.List] request.
     */
    nodeGroupId: string;

    /**
     * Field mask that specifies which fields of the node group are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the node group.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the node group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * Node template for the node group.
     * Change may trigger nodes rolling reboot or recreate.
     */
    nodeTemplate?: NodeTemplate;

    /**
     * Scale policy of the node group.
     */
    scalePolicy?: ScalePolicy;

    /**
     * Allocation policy of the node group by the zones and regions.
     */
    allocationPolicy?: NodeGroupAllocationPolicy;

    /**
     * Version of Kubernetes components that runs on the nodes.
     */
    version?: UpdateVersionSpec;

    /**
     * Maintenance policy of the node group.
     */
    maintenancePolicy?: NodeGroupMaintenancePolicy;

    /**
     * Support for unsafe sysctl parameters. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/).
     */
    allowedUnsafeSysctls?: string[];

    /**
     * Taints that are applied to the nodes of the node group at creation time.
     */
    nodeTaints?: Taint[];

    /**
     * Labels that are assigned to the nodes of the node group at creation time.
     */
    nodeLabels?: { [s: string]: string };
}

export interface UpdateNodeGroupMetadata {
    /**
     * ID of the Node group that is being updated.
     */
    nodeGroupId: string;
}

export interface CreateNodeGroupRequest {
    /**
     * ID of the Kubernetes cluster to create a node group in.
     * To get the Kubernetes cluster ID, use a [ClusterService.List] request.
     */
    clusterId: string;

    /**
     * Name of the node group.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the node group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Node template for creating the node group.
     */
    nodeTemplate: NodeTemplate;

    /**
     * Scale policy of the node group.
     */
    scalePolicy: ScalePolicy;

    /**
     * Allocation policy of the node group by the zones and regions.
     */
    allocationPolicy?: NodeGroupAllocationPolicy;

    /**
     * Version of Kubernetes components that runs on the nodes.
     */
    version?: string;

    /**
     * Maintenance policy of the node group.
     */
    maintenancePolicy?: NodeGroupMaintenancePolicy;

    /**
     * Support for unsafe sysctl parameters. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/).
     */
    allowedUnsafeSysctls?: string[];

    /**
     * Taints that are applied to the nodes of the node group at creation time.
     */
    nodeTaints?: Taint[];

    /**
     * Labels that are assigned to the nodes of the node group at creation time.
     */
    nodeLabels?: { [s: string]: string };
}

export interface CreateNodeGroupMetadata {
    /**
     * ID of the node group that is being created.
     */
    nodeGroupId?: string;
}

export interface AutoUpgradeNodeGroupMetadata {
    /**
     * ID of the node group that is being auto upgraded.
     */
    nodeGroupId?: string;
}

export interface ListNodeGroupOperationsRequest {
    /**
     * ID of the node group to list operations for.
     */
    nodeGroupId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than [page_size], the service returns a [ListNodeGroupOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set `page_token` to the
     * [ListNodeGroupOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on [NodeGroup.name] field.
     */
    filter?: string;
}

export interface ListNodeGroupOperationsResponse {
    /**
     * List of operations for the specified node group.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListNodeGroupOperationsRequest.page_size], use the `next_page_token` as the value
     * for the [ListNodeGroupOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface VersionInfo {
    /**
     * Current Kubernetes version, format: major.minor (e.g. 1.15).
     */
    currentVersion?: string;

    /**
     * Newer revisions may include Kubernetes patches (e.g 1.15.1 -> 1.15.2) as well
     * as some internal component updates — new features or bug fixes in Yandex specific
     * components either on the master or nodes.
     */
    newRevisionAvailable?: boolean;

    /**
     * Description of the changes to be applied when updating to the latest
     * revision. Empty if new_revision_available is false.
     */
    newRevisionSummary?: string;

    /**
     * The current version is on the deprecation schedule, component (master or node group)
     * should be upgraded.
     */
    versionDeprecated?: boolean;
}

export interface UpdateVersionSpec {
    /**
     * Request update to a newer version of Kubernetes (1.x -> 1.y).
     */
    version?: string;

    /**
     * Request update to the latest revision for the current version.
     */
    latestRevision?: boolean;
}

/**
 * A set of methods for managing Kubernetes versions.
 */
export class VersionService {
    constructor(session?: Session);
    /**
     * Retrieves the list of versions in the specified release channel.
     */
    list(request: ListVersionsRequest): Promise<ListVersionsResponse>;
}

export interface ListVersionsRequest {}

export interface ListVersionsResponse {
    /**
     * Versions available in the specified release channel.
     */
    availableVersions?: AvailableVersions[];
}

export interface AvailableVersions {
    /**
     * Release channel: `RAPID`, `REGULAR` or `STABLE`. For more details see [documentation](https://cloud.yandex.ru/docs/managed-kubernetes/concepts/release-channels-and-updates).
     */
    releaseChannel?: ReleaseChannel;

    /**
     * Version of Kubernetes components.
     */
    versions?: string[];
}
