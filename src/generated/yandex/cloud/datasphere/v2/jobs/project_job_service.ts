/* eslint-disable */
import Long from 'long';
import {
    makeGenericClientConstructor,
    ChannelCredentials,
    ChannelOptions,
    UntypedServiceImplementation,
    handleUnaryCall,
    handleServerStreamingCall,
    Client,
    ClientUnaryCall,
    Metadata,
    CallOptions,
    ClientReadableStream,
    ServiceError,
} from '@grpc/grpc-js';
import _m0 from 'protobufjs/minimal';
import {
    JobParameters,
    JobResult,
    Job,
    JobProgress,
    JobMetadata,
    StorageFile,
    FileUploadError,
    OutputDataset,
    File,
} from '../../../../../yandex/cloud/datasphere/v2/jobs/jobs';
import { Duration } from '../../../../../google/protobuf/duration';
import { Timestamp } from '../../../../../google/protobuf/timestamp';
import { Operation } from '../../../../../yandex/cloud/operation/operation';
import { Empty } from '../../../../../google/protobuf/empty';

export const protobufPackage = 'yandex.cloud.datasphere.v2.jobs';

export enum StandardStream {
    STANDARD_STREAM_UNSPECIFIED = 0,
    /** OUT - Stdout. */
    OUT = 1,
    /** ERR - Stderr. */
    ERR = 2,
    UNRECOGNIZED = -1,
}

export function standardStreamFromJSON(object: any): StandardStream {
    switch (object) {
        case 0:
        case 'STANDARD_STREAM_UNSPECIFIED':
            return StandardStream.STANDARD_STREAM_UNSPECIFIED;
        case 1:
        case 'OUT':
            return StandardStream.OUT;
        case 2:
        case 'ERR':
            return StandardStream.ERR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return StandardStream.UNRECOGNIZED;
    }
}

export function standardStreamToJSON(object: StandardStream): string {
    switch (object) {
        case StandardStream.STANDARD_STREAM_UNSPECIFIED:
            return 'STANDARD_STREAM_UNSPECIFIED';
        case StandardStream.OUT:
            return 'OUT';
        case StandardStream.ERR:
            return 'ERR';
        default:
            return 'UNKNOWN';
    }
}

export interface CreateProjectJobRequest {
    /** ID of the project. */
    projectId: string;
    /** Parameters of the job. */
    jobParameters?: JobParameters;
    /** Config of the job. */
    config: string;
    /** Name of the job. */
    name: string;
    /** Description of the job. */
    desc: string;
    /** Job data TTL. */
    dataTtl?: Duration;
}

export interface CreateProjectJobMetadata {
    /** ID of the project. */
    projectId: string;
    /** Job ID. */
    jobId: string;
}

export interface CreateProjectJobResponse {
    /** ID of the job. */
    jobId: string;
    /** Files to upload with their presigned URLs for upload. */
    uploadFiles: StorageFile[];
}

export interface CloneProjectJobRequest {
    /** ID of job to be cloned. */
    sourceJobId: string;
    /** Parameters overrides. */
    jobParametersOverrides?: JobParameters;
    /** New job name. */
    name: string;
    /** New job description */
    desc: string;
    /** Data ttl. */
    dataTtl?: Duration;
}

export interface CloneProjectJobResponse {
    /** Job ID. */
    jobId: string;
    /**
     * Files with presigned URLs generated by server to upload them to storage. Order is arbitrary.
     *
     * Upload files include input files, executable file (python main script or binary executable) and local modules
     * in case of python.
     *
     * If file was already uploaded, there will be no element for it.
     */
    uploadFiles: StorageFile[];
}

export interface CloneProjectJobMetadata {
    projectId: string;
    jobId: string;
}

export interface ExecuteProjectJobRequest {
    /** ID of the job. */
    jobId: string;
}

export interface ExecuteProjectJobResponse {
    /** Uploaded output files with URLs. */
    outputFiles: StorageFile[];
    /** Output file errors */
    outputFilesErrors: FileUploadError[];
    /** Created datasets */
    outputDatasets: OutputDataset[];
    /** Result of the job. */
    result?: JobResult;
}

export interface ExecuteProjectJobMetadata {
    /**
     * Instance of the job.
     *
     * @deprecated
     */
    job?: Job;
    /** Job progress info */
    progress?: JobProgress;
    /** Job metadata with main job info */
    metadata?: JobMetadata;
}

export interface CancelProjectJobRequest {
    /** ID of the job. */
    jobId: string;
    /** Optional cancellation reason. */
    reason: string;
    /** If the job is launched with graceful shutdown support, the shutdown will be performed gracefully */
    graceful: boolean;
}

export interface ReadProjectJobStdLogsRequest {
    /** ID of the job. */
    jobId: string;
    /** Log offset. */
    offset: number;
}

export interface ReadProjectJobStdLogsResponse {
    logs: StdLog[];
    /** Log offset. */
    offset: number;
}

export interface ReadProjectJobLogsRequest {
    /** ID of the job. */
    jobId: string;
    /** Log offset. */
    offset: number;
}

export interface ReadProjectJobLogsResponse {
    logs: LogMessage[];
    /** Log offset. */
    offset: number;
}

export interface DownloadProjectJobFilesRequest {
    jobId: string;
    files: File[];
}

export interface DownloadProjectJobFilesResponse {
    downloadFiles: StorageFile[];
}

export interface ListProjectJobRequest {
    /** ID of the project. */
    projectId: string;
    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListProjectJobResponse.page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize: number;
    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListProjectJobResponse.page_token] returned by a previous list request.
     */
    pageToken: string;
    /**
     * restrictions:
     *   * only `status` field is supported
     *   * only `IN` operator is supported
     * example:
     *   * only running jobs == "status IN (EXECUTING, UPLOADING_OUTPUT)"
     */
    filter: string;
}

export interface ListProjectJobResponse {
    /** Instances of the jobs. */
    jobs: Job[];
    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListProjectJobRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListProjectJobRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [page_token] to continue paging through the results.
     */
    nextPageToken: string;
}

export interface GetProjectJobRequest {
    /** ID of the job. */
    jobId: string;
}

export interface DeleteProjectJobRequest {
    /** ID of the job. */
    jobId: string;
}

export interface DeleteProjectJobMetadata {
    /** ID of the job. */
    jobId: string;
}

export interface DeleteProjectJobDataRequest {
    /** ID of the job. */
    jobId: string;
}

export interface DeleteProjectJobDataMetadata {
    /** ID of the job. */
    jobId: string;
}

export interface DeleteProjectJobDataResponse {}

export interface DeleteAllProjectJobDataRequest {
    projectId: string;
}

export interface DeleteAllProjectJobDataMetadata {
    projectId: string;
}

export interface DeleteAllProjectJobDataResponse {}

export interface SetProjectJobDataTtlRequest {
    jobId: string;
    ttl?: Duration;
}

export interface SetProjectJobDataTtlResponse {}

export interface StdLog {
    /** Log contents. */
    content: Buffer;
    /** Log type. */
    type: StdLog_Type;
}

export enum StdLog_Type {
    TYPE_UNSPECIFIED = 0,
    /** OUT - stdout. */
    OUT = 1,
    /** ERR - stderr. */
    ERR = 2,
    UNRECOGNIZED = -1,
}

export function stdLog_TypeFromJSON(object: any): StdLog_Type {
    switch (object) {
        case 0:
        case 'TYPE_UNSPECIFIED':
            return StdLog_Type.TYPE_UNSPECIFIED;
        case 1:
        case 'OUT':
            return StdLog_Type.OUT;
        case 2:
        case 'ERR':
            return StdLog_Type.ERR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return StdLog_Type.UNRECOGNIZED;
    }
}

export function stdLog_TypeToJSON(object: StdLog_Type): string {
    switch (object) {
        case StdLog_Type.TYPE_UNSPECIFIED:
            return 'TYPE_UNSPECIFIED';
        case StdLog_Type.OUT:
            return 'OUT';
        case StdLog_Type.ERR:
            return 'ERR';
        default:
            return 'UNKNOWN';
    }
}

export interface LogMessage {
    /** Log message contents. */
    content: Buffer;
    /** Log message creation timestamp. */
    createdAt?: Date;
    /** Program standard streams. */
    standardStream: StandardStream | undefined;
    /** System debug log files. */
    filePath: string | undefined;
}

const baseCreateProjectJobRequest: object = { projectId: '', config: '', name: '', desc: '' };

export const CreateProjectJobRequest = {
    encode(message: CreateProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        if (message.jobParameters !== undefined) {
            JobParameters.encode(message.jobParameters, writer.uint32(18).fork()).ldelim();
        }
        if (message.config !== '') {
            writer.uint32(26).string(message.config);
        }
        if (message.name !== '') {
            writer.uint32(34).string(message.name);
        }
        if (message.desc !== '') {
            writer.uint32(42).string(message.desc);
        }
        if (message.dataTtl !== undefined) {
            Duration.encode(message.dataTtl, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CreateProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCreateProjectJobRequest } as CreateProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 2:
                    message.jobParameters = JobParameters.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.config = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.desc = reader.string();
                    break;
                case 6:
                    message.dataTtl = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateProjectJobRequest {
        const message = { ...baseCreateProjectJobRequest } as CreateProjectJobRequest;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        message.jobParameters =
            object.jobParameters !== undefined && object.jobParameters !== null
                ? JobParameters.fromJSON(object.jobParameters)
                : undefined;
        message.config =
            object.config !== undefined && object.config !== null ? String(object.config) : '';
        message.name = object.name !== undefined && object.name !== null ? String(object.name) : '';
        message.desc = object.desc !== undefined && object.desc !== null ? String(object.desc) : '';
        message.dataTtl =
            object.dataTtl !== undefined && object.dataTtl !== null
                ? Duration.fromJSON(object.dataTtl)
                : undefined;
        return message;
    },

    toJSON(message: CreateProjectJobRequest): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        message.jobParameters !== undefined &&
            (obj.jobParameters = message.jobParameters
                ? JobParameters.toJSON(message.jobParameters)
                : undefined);
        message.config !== undefined && (obj.config = message.config);
        message.name !== undefined && (obj.name = message.name);
        message.desc !== undefined && (obj.desc = message.desc);
        message.dataTtl !== undefined &&
            (obj.dataTtl = message.dataTtl ? Duration.toJSON(message.dataTtl) : undefined);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CreateProjectJobRequest>, I>>(
        object: I,
    ): CreateProjectJobRequest {
        const message = { ...baseCreateProjectJobRequest } as CreateProjectJobRequest;
        message.projectId = object.projectId ?? '';
        message.jobParameters =
            object.jobParameters !== undefined && object.jobParameters !== null
                ? JobParameters.fromPartial(object.jobParameters)
                : undefined;
        message.config = object.config ?? '';
        message.name = object.name ?? '';
        message.desc = object.desc ?? '';
        message.dataTtl =
            object.dataTtl !== undefined && object.dataTtl !== null
                ? Duration.fromPartial(object.dataTtl)
                : undefined;
        return message;
    },
};

const baseCreateProjectJobMetadata: object = { projectId: '', jobId: '' };

export const CreateProjectJobMetadata = {
    encode(
        message: CreateProjectJobMetadata,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        if (message.jobId !== '') {
            writer.uint32(18).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CreateProjectJobMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCreateProjectJobMetadata } as CreateProjectJobMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 2:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateProjectJobMetadata {
        const message = { ...baseCreateProjectJobMetadata } as CreateProjectJobMetadata;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: CreateProjectJobMetadata): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CreateProjectJobMetadata>, I>>(
        object: I,
    ): CreateProjectJobMetadata {
        const message = { ...baseCreateProjectJobMetadata } as CreateProjectJobMetadata;
        message.projectId = object.projectId ?? '';
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseCreateProjectJobResponse: object = { jobId: '' };

export const CreateProjectJobResponse = {
    encode(
        message: CreateProjectJobResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        for (const v of message.uploadFiles) {
            StorageFile.encode(v!, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CreateProjectJobResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCreateProjectJobResponse } as CreateProjectJobResponse;
        message.uploadFiles = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.uploadFiles.push(StorageFile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateProjectJobResponse {
        const message = { ...baseCreateProjectJobResponse } as CreateProjectJobResponse;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.uploadFiles = (object.uploadFiles ?? []).map((e: any) => StorageFile.fromJSON(e));
        return message;
    },

    toJSON(message: CreateProjectJobResponse): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        if (message.uploadFiles) {
            obj.uploadFiles = message.uploadFiles.map((e) =>
                e ? StorageFile.toJSON(e) : undefined,
            );
        } else {
            obj.uploadFiles = [];
        }
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CreateProjectJobResponse>, I>>(
        object: I,
    ): CreateProjectJobResponse {
        const message = { ...baseCreateProjectJobResponse } as CreateProjectJobResponse;
        message.jobId = object.jobId ?? '';
        message.uploadFiles = object.uploadFiles?.map((e) => StorageFile.fromPartial(e)) || [];
        return message;
    },
};

const baseCloneProjectJobRequest: object = { sourceJobId: '', name: '', desc: '' };

export const CloneProjectJobRequest = {
    encode(message: CloneProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.sourceJobId !== '') {
            writer.uint32(10).string(message.sourceJobId);
        }
        if (message.jobParametersOverrides !== undefined) {
            JobParameters.encode(message.jobParametersOverrides, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(26).string(message.name);
        }
        if (message.desc !== '') {
            writer.uint32(34).string(message.desc);
        }
        if (message.dataTtl !== undefined) {
            Duration.encode(message.dataTtl, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CloneProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCloneProjectJobRequest } as CloneProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sourceJobId = reader.string();
                    break;
                case 2:
                    message.jobParametersOverrides = JobParameters.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.desc = reader.string();
                    break;
                case 5:
                    message.dataTtl = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CloneProjectJobRequest {
        const message = { ...baseCloneProjectJobRequest } as CloneProjectJobRequest;
        message.sourceJobId =
            object.sourceJobId !== undefined && object.sourceJobId !== null
                ? String(object.sourceJobId)
                : '';
        message.jobParametersOverrides =
            object.jobParametersOverrides !== undefined && object.jobParametersOverrides !== null
                ? JobParameters.fromJSON(object.jobParametersOverrides)
                : undefined;
        message.name = object.name !== undefined && object.name !== null ? String(object.name) : '';
        message.desc = object.desc !== undefined && object.desc !== null ? String(object.desc) : '';
        message.dataTtl =
            object.dataTtl !== undefined && object.dataTtl !== null
                ? Duration.fromJSON(object.dataTtl)
                : undefined;
        return message;
    },

    toJSON(message: CloneProjectJobRequest): unknown {
        const obj: any = {};
        message.sourceJobId !== undefined && (obj.sourceJobId = message.sourceJobId);
        message.jobParametersOverrides !== undefined &&
            (obj.jobParametersOverrides = message.jobParametersOverrides
                ? JobParameters.toJSON(message.jobParametersOverrides)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.desc !== undefined && (obj.desc = message.desc);
        message.dataTtl !== undefined &&
            (obj.dataTtl = message.dataTtl ? Duration.toJSON(message.dataTtl) : undefined);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CloneProjectJobRequest>, I>>(
        object: I,
    ): CloneProjectJobRequest {
        const message = { ...baseCloneProjectJobRequest } as CloneProjectJobRequest;
        message.sourceJobId = object.sourceJobId ?? '';
        message.jobParametersOverrides =
            object.jobParametersOverrides !== undefined && object.jobParametersOverrides !== null
                ? JobParameters.fromPartial(object.jobParametersOverrides)
                : undefined;
        message.name = object.name ?? '';
        message.desc = object.desc ?? '';
        message.dataTtl =
            object.dataTtl !== undefined && object.dataTtl !== null
                ? Duration.fromPartial(object.dataTtl)
                : undefined;
        return message;
    },
};

const baseCloneProjectJobResponse: object = { jobId: '' };

export const CloneProjectJobResponse = {
    encode(message: CloneProjectJobResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        for (const v of message.uploadFiles) {
            StorageFile.encode(v!, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CloneProjectJobResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCloneProjectJobResponse } as CloneProjectJobResponse;
        message.uploadFiles = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.uploadFiles.push(StorageFile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CloneProjectJobResponse {
        const message = { ...baseCloneProjectJobResponse } as CloneProjectJobResponse;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.uploadFiles = (object.uploadFiles ?? []).map((e: any) => StorageFile.fromJSON(e));
        return message;
    },

    toJSON(message: CloneProjectJobResponse): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        if (message.uploadFiles) {
            obj.uploadFiles = message.uploadFiles.map((e) =>
                e ? StorageFile.toJSON(e) : undefined,
            );
        } else {
            obj.uploadFiles = [];
        }
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CloneProjectJobResponse>, I>>(
        object: I,
    ): CloneProjectJobResponse {
        const message = { ...baseCloneProjectJobResponse } as CloneProjectJobResponse;
        message.jobId = object.jobId ?? '';
        message.uploadFiles = object.uploadFiles?.map((e) => StorageFile.fromPartial(e)) || [];
        return message;
    },
};

const baseCloneProjectJobMetadata: object = { projectId: '', jobId: '' };

export const CloneProjectJobMetadata = {
    encode(message: CloneProjectJobMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        if (message.jobId !== '') {
            writer.uint32(18).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CloneProjectJobMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCloneProjectJobMetadata } as CloneProjectJobMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 2:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CloneProjectJobMetadata {
        const message = { ...baseCloneProjectJobMetadata } as CloneProjectJobMetadata;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: CloneProjectJobMetadata): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CloneProjectJobMetadata>, I>>(
        object: I,
    ): CloneProjectJobMetadata {
        const message = { ...baseCloneProjectJobMetadata } as CloneProjectJobMetadata;
        message.projectId = object.projectId ?? '';
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseExecuteProjectJobRequest: object = { jobId: '' };

export const ExecuteProjectJobRequest = {
    encode(
        message: ExecuteProjectJobRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseExecuteProjectJobRequest } as ExecuteProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ExecuteProjectJobRequest {
        const message = { ...baseExecuteProjectJobRequest } as ExecuteProjectJobRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: ExecuteProjectJobRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ExecuteProjectJobRequest>, I>>(
        object: I,
    ): ExecuteProjectJobRequest {
        const message = { ...baseExecuteProjectJobRequest } as ExecuteProjectJobRequest;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseExecuteProjectJobResponse: object = {};

export const ExecuteProjectJobResponse = {
    encode(
        message: ExecuteProjectJobResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        for (const v of message.outputFiles) {
            StorageFile.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputFilesErrors) {
            FileUploadError.encode(v!, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.outputDatasets) {
            OutputDataset.encode(v!, writer.uint32(26).fork()).ldelim();
        }
        if (message.result !== undefined) {
            JobResult.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteProjectJobResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseExecuteProjectJobResponse } as ExecuteProjectJobResponse;
        message.outputFiles = [];
        message.outputFilesErrors = [];
        message.outputDatasets = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outputFiles.push(StorageFile.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.outputFilesErrors.push(FileUploadError.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.outputDatasets.push(OutputDataset.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.result = JobResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ExecuteProjectJobResponse {
        const message = { ...baseExecuteProjectJobResponse } as ExecuteProjectJobResponse;
        message.outputFiles = (object.outputFiles ?? []).map((e: any) => StorageFile.fromJSON(e));
        message.outputFilesErrors = (object.outputFilesErrors ?? []).map((e: any) =>
            FileUploadError.fromJSON(e),
        );
        message.outputDatasets = (object.outputDatasets ?? []).map((e: any) =>
            OutputDataset.fromJSON(e),
        );
        message.result =
            object.result !== undefined && object.result !== null
                ? JobResult.fromJSON(object.result)
                : undefined;
        return message;
    },

    toJSON(message: ExecuteProjectJobResponse): unknown {
        const obj: any = {};
        if (message.outputFiles) {
            obj.outputFiles = message.outputFiles.map((e) =>
                e ? StorageFile.toJSON(e) : undefined,
            );
        } else {
            obj.outputFiles = [];
        }
        if (message.outputFilesErrors) {
            obj.outputFilesErrors = message.outputFilesErrors.map((e) =>
                e ? FileUploadError.toJSON(e) : undefined,
            );
        } else {
            obj.outputFilesErrors = [];
        }
        if (message.outputDatasets) {
            obj.outputDatasets = message.outputDatasets.map((e) =>
                e ? OutputDataset.toJSON(e) : undefined,
            );
        } else {
            obj.outputDatasets = [];
        }
        message.result !== undefined &&
            (obj.result = message.result ? JobResult.toJSON(message.result) : undefined);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ExecuteProjectJobResponse>, I>>(
        object: I,
    ): ExecuteProjectJobResponse {
        const message = { ...baseExecuteProjectJobResponse } as ExecuteProjectJobResponse;
        message.outputFiles = object.outputFiles?.map((e) => StorageFile.fromPartial(e)) || [];
        message.outputFilesErrors =
            object.outputFilesErrors?.map((e) => FileUploadError.fromPartial(e)) || [];
        message.outputDatasets =
            object.outputDatasets?.map((e) => OutputDataset.fromPartial(e)) || [];
        message.result =
            object.result !== undefined && object.result !== null
                ? JobResult.fromPartial(object.result)
                : undefined;
        return message;
    },
};

const baseExecuteProjectJobMetadata: object = {};

export const ExecuteProjectJobMetadata = {
    encode(
        message: ExecuteProjectJobMetadata,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.job !== undefined) {
            Job.encode(message.job, writer.uint32(10).fork()).ldelim();
        }
        if (message.progress !== undefined) {
            JobProgress.encode(message.progress, writer.uint32(18).fork()).ldelim();
        }
        if (message.metadata !== undefined) {
            JobMetadata.encode(message.metadata, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteProjectJobMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseExecuteProjectJobMetadata } as ExecuteProjectJobMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.job = Job.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.progress = JobProgress.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.metadata = JobMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ExecuteProjectJobMetadata {
        const message = { ...baseExecuteProjectJobMetadata } as ExecuteProjectJobMetadata;
        message.job =
            object.job !== undefined && object.job !== null ? Job.fromJSON(object.job) : undefined;
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? JobProgress.fromJSON(object.progress)
                : undefined;
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? JobMetadata.fromJSON(object.metadata)
                : undefined;
        return message;
    },

    toJSON(message: ExecuteProjectJobMetadata): unknown {
        const obj: any = {};
        message.job !== undefined && (obj.job = message.job ? Job.toJSON(message.job) : undefined);
        message.progress !== undefined &&
            (obj.progress = message.progress ? JobProgress.toJSON(message.progress) : undefined);
        message.metadata !== undefined &&
            (obj.metadata = message.metadata ? JobMetadata.toJSON(message.metadata) : undefined);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ExecuteProjectJobMetadata>, I>>(
        object: I,
    ): ExecuteProjectJobMetadata {
        const message = { ...baseExecuteProjectJobMetadata } as ExecuteProjectJobMetadata;
        message.job =
            object.job !== undefined && object.job !== null
                ? Job.fromPartial(object.job)
                : undefined;
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? JobProgress.fromPartial(object.progress)
                : undefined;
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? JobMetadata.fromPartial(object.metadata)
                : undefined;
        return message;
    },
};

const baseCancelProjectJobRequest: object = { jobId: '', reason: '', graceful: false };

export const CancelProjectJobRequest = {
    encode(message: CancelProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        if (message.reason !== '') {
            writer.uint32(18).string(message.reason);
        }
        if (message.graceful === true) {
            writer.uint32(24).bool(message.graceful);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CancelProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCancelProjectJobRequest } as CancelProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.graceful = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CancelProjectJobRequest {
        const message = { ...baseCancelProjectJobRequest } as CancelProjectJobRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.reason =
            object.reason !== undefined && object.reason !== null ? String(object.reason) : '';
        message.graceful =
            object.graceful !== undefined && object.graceful !== null
                ? Boolean(object.graceful)
                : false;
        return message;
    },

    toJSON(message: CancelProjectJobRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        message.reason !== undefined && (obj.reason = message.reason);
        message.graceful !== undefined && (obj.graceful = message.graceful);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<CancelProjectJobRequest>, I>>(
        object: I,
    ): CancelProjectJobRequest {
        const message = { ...baseCancelProjectJobRequest } as CancelProjectJobRequest;
        message.jobId = object.jobId ?? '';
        message.reason = object.reason ?? '';
        message.graceful = object.graceful ?? false;
        return message;
    },
};

const baseReadProjectJobStdLogsRequest: object = { jobId: '', offset: 0 };

export const ReadProjectJobStdLogsRequest = {
    encode(
        message: ReadProjectJobStdLogsRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int64(message.offset);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ReadProjectJobStdLogsRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseReadProjectJobStdLogsRequest } as ReadProjectJobStdLogsRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.offset = longToNumber(reader.int64() as Long);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ReadProjectJobStdLogsRequest {
        const message = { ...baseReadProjectJobStdLogsRequest } as ReadProjectJobStdLogsRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.offset =
            object.offset !== undefined && object.offset !== null ? Number(object.offset) : 0;
        return message;
    },

    toJSON(message: ReadProjectJobStdLogsRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ReadProjectJobStdLogsRequest>, I>>(
        object: I,
    ): ReadProjectJobStdLogsRequest {
        const message = { ...baseReadProjectJobStdLogsRequest } as ReadProjectJobStdLogsRequest;
        message.jobId = object.jobId ?? '';
        message.offset = object.offset ?? 0;
        return message;
    },
};

const baseReadProjectJobStdLogsResponse: object = { offset: 0 };

export const ReadProjectJobStdLogsResponse = {
    encode(
        message: ReadProjectJobStdLogsResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        for (const v of message.logs) {
            StdLog.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        if (message.offset !== 0) {
            writer.uint32(16).int64(message.offset);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ReadProjectJobStdLogsResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseReadProjectJobStdLogsResponse } as ReadProjectJobStdLogsResponse;
        message.logs = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.logs.push(StdLog.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.offset = longToNumber(reader.int64() as Long);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ReadProjectJobStdLogsResponse {
        const message = { ...baseReadProjectJobStdLogsResponse } as ReadProjectJobStdLogsResponse;
        message.logs = (object.logs ?? []).map((e: any) => StdLog.fromJSON(e));
        message.offset =
            object.offset !== undefined && object.offset !== null ? Number(object.offset) : 0;
        return message;
    },

    toJSON(message: ReadProjectJobStdLogsResponse): unknown {
        const obj: any = {};
        if (message.logs) {
            obj.logs = message.logs.map((e) => (e ? StdLog.toJSON(e) : undefined));
        } else {
            obj.logs = [];
        }
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ReadProjectJobStdLogsResponse>, I>>(
        object: I,
    ): ReadProjectJobStdLogsResponse {
        const message = { ...baseReadProjectJobStdLogsResponse } as ReadProjectJobStdLogsResponse;
        message.logs = object.logs?.map((e) => StdLog.fromPartial(e)) || [];
        message.offset = object.offset ?? 0;
        return message;
    },
};

const baseReadProjectJobLogsRequest: object = { jobId: '', offset: 0 };

export const ReadProjectJobLogsRequest = {
    encode(
        message: ReadProjectJobLogsRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int64(message.offset);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ReadProjectJobLogsRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseReadProjectJobLogsRequest } as ReadProjectJobLogsRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.offset = longToNumber(reader.int64() as Long);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ReadProjectJobLogsRequest {
        const message = { ...baseReadProjectJobLogsRequest } as ReadProjectJobLogsRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.offset =
            object.offset !== undefined && object.offset !== null ? Number(object.offset) : 0;
        return message;
    },

    toJSON(message: ReadProjectJobLogsRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ReadProjectJobLogsRequest>, I>>(
        object: I,
    ): ReadProjectJobLogsRequest {
        const message = { ...baseReadProjectJobLogsRequest } as ReadProjectJobLogsRequest;
        message.jobId = object.jobId ?? '';
        message.offset = object.offset ?? 0;
        return message;
    },
};

const baseReadProjectJobLogsResponse: object = { offset: 0 };

export const ReadProjectJobLogsResponse = {
    encode(
        message: ReadProjectJobLogsResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        for (const v of message.logs) {
            LogMessage.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        if (message.offset !== 0) {
            writer.uint32(16).int64(message.offset);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ReadProjectJobLogsResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseReadProjectJobLogsResponse } as ReadProjectJobLogsResponse;
        message.logs = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.logs.push(LogMessage.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.offset = longToNumber(reader.int64() as Long);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ReadProjectJobLogsResponse {
        const message = { ...baseReadProjectJobLogsResponse } as ReadProjectJobLogsResponse;
        message.logs = (object.logs ?? []).map((e: any) => LogMessage.fromJSON(e));
        message.offset =
            object.offset !== undefined && object.offset !== null ? Number(object.offset) : 0;
        return message;
    },

    toJSON(message: ReadProjectJobLogsResponse): unknown {
        const obj: any = {};
        if (message.logs) {
            obj.logs = message.logs.map((e) => (e ? LogMessage.toJSON(e) : undefined));
        } else {
            obj.logs = [];
        }
        message.offset !== undefined && (obj.offset = Math.round(message.offset));
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ReadProjectJobLogsResponse>, I>>(
        object: I,
    ): ReadProjectJobLogsResponse {
        const message = { ...baseReadProjectJobLogsResponse } as ReadProjectJobLogsResponse;
        message.logs = object.logs?.map((e) => LogMessage.fromPartial(e)) || [];
        message.offset = object.offset ?? 0;
        return message;
    },
};

const baseDownloadProjectJobFilesRequest: object = { jobId: '' };

export const DownloadProjectJobFilesRequest = {
    encode(
        message: DownloadProjectJobFilesRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        for (const v of message.files) {
            File.encode(v!, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProjectJobFilesRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDownloadProjectJobFilesRequest } as DownloadProjectJobFilesRequest;
        message.files = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.files.push(File.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DownloadProjectJobFilesRequest {
        const message = { ...baseDownloadProjectJobFilesRequest } as DownloadProjectJobFilesRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.files = (object.files ?? []).map((e: any) => File.fromJSON(e));
        return message;
    },

    toJSON(message: DownloadProjectJobFilesRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        if (message.files) {
            obj.files = message.files.map((e) => (e ? File.toJSON(e) : undefined));
        } else {
            obj.files = [];
        }
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DownloadProjectJobFilesRequest>, I>>(
        object: I,
    ): DownloadProjectJobFilesRequest {
        const message = { ...baseDownloadProjectJobFilesRequest } as DownloadProjectJobFilesRequest;
        message.jobId = object.jobId ?? '';
        message.files = object.files?.map((e) => File.fromPartial(e)) || [];
        return message;
    },
};

const baseDownloadProjectJobFilesResponse: object = {};

export const DownloadProjectJobFilesResponse = {
    encode(
        message: DownloadProjectJobFilesResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        for (const v of message.downloadFiles) {
            StorageFile.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProjectJobFilesResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDownloadProjectJobFilesResponse,
        } as DownloadProjectJobFilesResponse;
        message.downloadFiles = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.downloadFiles.push(StorageFile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DownloadProjectJobFilesResponse {
        const message = {
            ...baseDownloadProjectJobFilesResponse,
        } as DownloadProjectJobFilesResponse;
        message.downloadFiles = (object.downloadFiles ?? []).map((e: any) =>
            StorageFile.fromJSON(e),
        );
        return message;
    },

    toJSON(message: DownloadProjectJobFilesResponse): unknown {
        const obj: any = {};
        if (message.downloadFiles) {
            obj.downloadFiles = message.downloadFiles.map((e) =>
                e ? StorageFile.toJSON(e) : undefined,
            );
        } else {
            obj.downloadFiles = [];
        }
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DownloadProjectJobFilesResponse>, I>>(
        object: I,
    ): DownloadProjectJobFilesResponse {
        const message = {
            ...baseDownloadProjectJobFilesResponse,
        } as DownloadProjectJobFilesResponse;
        message.downloadFiles = object.downloadFiles?.map((e) => StorageFile.fromPartial(e)) || [];
        return message;
    },
};

const baseListProjectJobRequest: object = { projectId: '', pageSize: 0, pageToken: '', filter: '' };

export const ListProjectJobRequest = {
    encode(message: ListProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        if (message.pageSize !== 0) {
            writer.uint32(16).int64(message.pageSize);
        }
        if (message.pageToken !== '') {
            writer.uint32(26).string(message.pageToken);
        }
        if (message.filter !== '') {
            writer.uint32(34).string(message.filter);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ListProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseListProjectJobRequest } as ListProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 2:
                    message.pageSize = longToNumber(reader.int64() as Long);
                    break;
                case 3:
                    message.pageToken = reader.string();
                    break;
                case 4:
                    message.filter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListProjectJobRequest {
        const message = { ...baseListProjectJobRequest } as ListProjectJobRequest;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        message.pageSize =
            object.pageSize !== undefined && object.pageSize !== null ? Number(object.pageSize) : 0;
        message.pageToken =
            object.pageToken !== undefined && object.pageToken !== null
                ? String(object.pageToken)
                : '';
        message.filter =
            object.filter !== undefined && object.filter !== null ? String(object.filter) : '';
        return message;
    },

    toJSON(message: ListProjectJobRequest): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
        message.pageToken !== undefined && (obj.pageToken = message.pageToken);
        message.filter !== undefined && (obj.filter = message.filter);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ListProjectJobRequest>, I>>(
        object: I,
    ): ListProjectJobRequest {
        const message = { ...baseListProjectJobRequest } as ListProjectJobRequest;
        message.projectId = object.projectId ?? '';
        message.pageSize = object.pageSize ?? 0;
        message.pageToken = object.pageToken ?? '';
        message.filter = object.filter ?? '';
        return message;
    },
};

const baseListProjectJobResponse: object = { nextPageToken: '' };

export const ListProjectJobResponse = {
    encode(message: ListProjectJobResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        for (const v of message.jobs) {
            Job.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        if (message.nextPageToken !== '') {
            writer.uint32(18).string(message.nextPageToken);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ListProjectJobResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseListProjectJobResponse } as ListProjectJobResponse;
        message.jobs = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobs.push(Job.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListProjectJobResponse {
        const message = { ...baseListProjectJobResponse } as ListProjectJobResponse;
        message.jobs = (object.jobs ?? []).map((e: any) => Job.fromJSON(e));
        message.nextPageToken =
            object.nextPageToken !== undefined && object.nextPageToken !== null
                ? String(object.nextPageToken)
                : '';
        return message;
    },

    toJSON(message: ListProjectJobResponse): unknown {
        const obj: any = {};
        if (message.jobs) {
            obj.jobs = message.jobs.map((e) => (e ? Job.toJSON(e) : undefined));
        } else {
            obj.jobs = [];
        }
        message.nextPageToken !== undefined && (obj.nextPageToken = message.nextPageToken);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<ListProjectJobResponse>, I>>(
        object: I,
    ): ListProjectJobResponse {
        const message = { ...baseListProjectJobResponse } as ListProjectJobResponse;
        message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
        message.nextPageToken = object.nextPageToken ?? '';
        return message;
    },
};

const baseGetProjectJobRequest: object = { jobId: '' };

export const GetProjectJobRequest = {
    encode(message: GetProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseGetProjectJobRequest } as GetProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): GetProjectJobRequest {
        const message = { ...baseGetProjectJobRequest } as GetProjectJobRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: GetProjectJobRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<GetProjectJobRequest>, I>>(
        object: I,
    ): GetProjectJobRequest {
        const message = { ...baseGetProjectJobRequest } as GetProjectJobRequest;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseDeleteProjectJobRequest: object = { jobId: '' };

export const DeleteProjectJobRequest = {
    encode(message: DeleteProjectJobRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectJobRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteProjectJobRequest } as DeleteProjectJobRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteProjectJobRequest {
        const message = { ...baseDeleteProjectJobRequest } as DeleteProjectJobRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: DeleteProjectJobRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteProjectJobRequest>, I>>(
        object: I,
    ): DeleteProjectJobRequest {
        const message = { ...baseDeleteProjectJobRequest } as DeleteProjectJobRequest;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseDeleteProjectJobMetadata: object = { jobId: '' };

export const DeleteProjectJobMetadata = {
    encode(
        message: DeleteProjectJobMetadata,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectJobMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteProjectJobMetadata } as DeleteProjectJobMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteProjectJobMetadata {
        const message = { ...baseDeleteProjectJobMetadata } as DeleteProjectJobMetadata;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: DeleteProjectJobMetadata): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteProjectJobMetadata>, I>>(
        object: I,
    ): DeleteProjectJobMetadata {
        const message = { ...baseDeleteProjectJobMetadata } as DeleteProjectJobMetadata;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseDeleteProjectJobDataRequest: object = { jobId: '' };

export const DeleteProjectJobDataRequest = {
    encode(
        message: DeleteProjectJobDataRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectJobDataRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteProjectJobDataRequest } as DeleteProjectJobDataRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteProjectJobDataRequest {
        const message = { ...baseDeleteProjectJobDataRequest } as DeleteProjectJobDataRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: DeleteProjectJobDataRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteProjectJobDataRequest>, I>>(
        object: I,
    ): DeleteProjectJobDataRequest {
        const message = { ...baseDeleteProjectJobDataRequest } as DeleteProjectJobDataRequest;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseDeleteProjectJobDataMetadata: object = { jobId: '' };

export const DeleteProjectJobDataMetadata = {
    encode(
        message: DeleteProjectJobDataMetadata,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectJobDataMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteProjectJobDataMetadata } as DeleteProjectJobDataMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteProjectJobDataMetadata {
        const message = { ...baseDeleteProjectJobDataMetadata } as DeleteProjectJobDataMetadata;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        return message;
    },

    toJSON(message: DeleteProjectJobDataMetadata): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteProjectJobDataMetadata>, I>>(
        object: I,
    ): DeleteProjectJobDataMetadata {
        const message = { ...baseDeleteProjectJobDataMetadata } as DeleteProjectJobDataMetadata;
        message.jobId = object.jobId ?? '';
        return message;
    },
};

const baseDeleteProjectJobDataResponse: object = {};

export const DeleteProjectJobDataResponse = {
    encode(_: DeleteProjectJobDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectJobDataResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteProjectJobDataResponse } as DeleteProjectJobDataResponse;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(_: any): DeleteProjectJobDataResponse {
        const message = { ...baseDeleteProjectJobDataResponse } as DeleteProjectJobDataResponse;
        return message;
    },

    toJSON(_: DeleteProjectJobDataResponse): unknown {
        const obj: any = {};
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteProjectJobDataResponse>, I>>(
        _: I,
    ): DeleteProjectJobDataResponse {
        const message = { ...baseDeleteProjectJobDataResponse } as DeleteProjectJobDataResponse;
        return message;
    },
};

const baseDeleteAllProjectJobDataRequest: object = { projectId: '' };

export const DeleteAllProjectJobDataRequest = {
    encode(
        message: DeleteAllProjectJobDataRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteAllProjectJobDataRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteAllProjectJobDataRequest } as DeleteAllProjectJobDataRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteAllProjectJobDataRequest {
        const message = { ...baseDeleteAllProjectJobDataRequest } as DeleteAllProjectJobDataRequest;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        return message;
    },

    toJSON(message: DeleteAllProjectJobDataRequest): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteAllProjectJobDataRequest>, I>>(
        object: I,
    ): DeleteAllProjectJobDataRequest {
        const message = { ...baseDeleteAllProjectJobDataRequest } as DeleteAllProjectJobDataRequest;
        message.projectId = object.projectId ?? '';
        return message;
    },
};

const baseDeleteAllProjectJobDataMetadata: object = { projectId: '' };

export const DeleteAllProjectJobDataMetadata = {
    encode(
        message: DeleteAllProjectJobDataMetadata,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.projectId !== '') {
            writer.uint32(10).string(message.projectId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteAllProjectJobDataMetadata {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDeleteAllProjectJobDataMetadata,
        } as DeleteAllProjectJobDataMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteAllProjectJobDataMetadata {
        const message = {
            ...baseDeleteAllProjectJobDataMetadata,
        } as DeleteAllProjectJobDataMetadata;
        message.projectId =
            object.projectId !== undefined && object.projectId !== null
                ? String(object.projectId)
                : '';
        return message;
    },

    toJSON(message: DeleteAllProjectJobDataMetadata): unknown {
        const obj: any = {};
        message.projectId !== undefined && (obj.projectId = message.projectId);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteAllProjectJobDataMetadata>, I>>(
        object: I,
    ): DeleteAllProjectJobDataMetadata {
        const message = {
            ...baseDeleteAllProjectJobDataMetadata,
        } as DeleteAllProjectJobDataMetadata;
        message.projectId = object.projectId ?? '';
        return message;
    },
};

const baseDeleteAllProjectJobDataResponse: object = {};

export const DeleteAllProjectJobDataResponse = {
    encode(
        _: DeleteAllProjectJobDataResponse,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteAllProjectJobDataResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDeleteAllProjectJobDataResponse,
        } as DeleteAllProjectJobDataResponse;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(_: any): DeleteAllProjectJobDataResponse {
        const message = {
            ...baseDeleteAllProjectJobDataResponse,
        } as DeleteAllProjectJobDataResponse;
        return message;
    },

    toJSON(_: DeleteAllProjectJobDataResponse): unknown {
        const obj: any = {};
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<DeleteAllProjectJobDataResponse>, I>>(
        _: I,
    ): DeleteAllProjectJobDataResponse {
        const message = {
            ...baseDeleteAllProjectJobDataResponse,
        } as DeleteAllProjectJobDataResponse;
        return message;
    },
};

const baseSetProjectJobDataTtlRequest: object = { jobId: '' };

export const SetProjectJobDataTtlRequest = {
    encode(
        message: SetProjectJobDataTtlRequest,
        writer: _m0.Writer = _m0.Writer.create(),
    ): _m0.Writer {
        if (message.jobId !== '') {
            writer.uint32(10).string(message.jobId);
        }
        if (message.ttl !== undefined) {
            Duration.encode(message.ttl, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): SetProjectJobDataTtlRequest {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseSetProjectJobDataTtlRequest } as SetProjectJobDataTtlRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jobId = reader.string();
                    break;
                case 2:
                    message.ttl = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): SetProjectJobDataTtlRequest {
        const message = { ...baseSetProjectJobDataTtlRequest } as SetProjectJobDataTtlRequest;
        message.jobId =
            object.jobId !== undefined && object.jobId !== null ? String(object.jobId) : '';
        message.ttl =
            object.ttl !== undefined && object.ttl !== null
                ? Duration.fromJSON(object.ttl)
                : undefined;
        return message;
    },

    toJSON(message: SetProjectJobDataTtlRequest): unknown {
        const obj: any = {};
        message.jobId !== undefined && (obj.jobId = message.jobId);
        message.ttl !== undefined &&
            (obj.ttl = message.ttl ? Duration.toJSON(message.ttl) : undefined);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<SetProjectJobDataTtlRequest>, I>>(
        object: I,
    ): SetProjectJobDataTtlRequest {
        const message = { ...baseSetProjectJobDataTtlRequest } as SetProjectJobDataTtlRequest;
        message.jobId = object.jobId ?? '';
        message.ttl =
            object.ttl !== undefined && object.ttl !== null
                ? Duration.fromPartial(object.ttl)
                : undefined;
        return message;
    },
};

const baseSetProjectJobDataTtlResponse: object = {};

export const SetProjectJobDataTtlResponse = {
    encode(_: SetProjectJobDataTtlResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): SetProjectJobDataTtlResponse {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseSetProjectJobDataTtlResponse } as SetProjectJobDataTtlResponse;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(_: any): SetProjectJobDataTtlResponse {
        const message = { ...baseSetProjectJobDataTtlResponse } as SetProjectJobDataTtlResponse;
        return message;
    },

    toJSON(_: SetProjectJobDataTtlResponse): unknown {
        const obj: any = {};
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<SetProjectJobDataTtlResponse>, I>>(
        _: I,
    ): SetProjectJobDataTtlResponse {
        const message = { ...baseSetProjectJobDataTtlResponse } as SetProjectJobDataTtlResponse;
        return message;
    },
};

const baseStdLog: object = { type: 0 };

export const StdLog = {
    encode(message: StdLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.content.length !== 0) {
            writer.uint32(10).bytes(message.content);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): StdLog {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseStdLog } as StdLog;
        message.content = Buffer.alloc(0);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.content = reader.bytes() as Buffer;
                    break;
                case 2:
                    message.type = reader.int32() as any;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): StdLog {
        const message = { ...baseStdLog } as StdLog;
        message.content =
            object.content !== undefined && object.content !== null
                ? Buffer.from(bytesFromBase64(object.content))
                : Buffer.alloc(0);
        message.type =
            object.type !== undefined && object.type !== null
                ? stdLog_TypeFromJSON(object.type)
                : 0;
        return message;
    },

    toJSON(message: StdLog): unknown {
        const obj: any = {};
        message.content !== undefined &&
            (obj.content = base64FromBytes(
                message.content !== undefined ? message.content : Buffer.alloc(0),
            ));
        message.type !== undefined && (obj.type = stdLog_TypeToJSON(message.type));
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<StdLog>, I>>(object: I): StdLog {
        const message = { ...baseStdLog } as StdLog;
        message.content = object.content ?? Buffer.alloc(0);
        message.type = object.type ?? 0;
        return message;
    },
};

const baseLogMessage: object = {};

export const LogMessage = {
    encode(message: LogMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
        if (message.content.length !== 0) {
            writer.uint32(10).bytes(message.content);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
        }
        if (message.standardStream !== undefined) {
            writer.uint32(24).int32(message.standardStream);
        }
        if (message.filePath !== undefined) {
            writer.uint32(34).string(message.filePath);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): LogMessage {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseLogMessage } as LogMessage;
        message.content = Buffer.alloc(0);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.content = reader.bytes() as Buffer;
                    break;
                case 2:
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.standardStream = reader.int32() as any;
                    break;
                case 4:
                    message.filePath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): LogMessage {
        const message = { ...baseLogMessage } as LogMessage;
        message.content =
            object.content !== undefined && object.content !== null
                ? Buffer.from(bytesFromBase64(object.content))
                : Buffer.alloc(0);
        message.createdAt =
            object.createdAt !== undefined && object.createdAt !== null
                ? fromJsonTimestamp(object.createdAt)
                : undefined;
        message.standardStream =
            object.standardStream !== undefined && object.standardStream !== null
                ? standardStreamFromJSON(object.standardStream)
                : undefined;
        message.filePath =
            object.filePath !== undefined && object.filePath !== null
                ? String(object.filePath)
                : undefined;
        return message;
    },

    toJSON(message: LogMessage): unknown {
        const obj: any = {};
        message.content !== undefined &&
            (obj.content = base64FromBytes(
                message.content !== undefined ? message.content : Buffer.alloc(0),
            ));
        message.createdAt !== undefined && (obj.createdAt = message.createdAt.toISOString());
        message.standardStream !== undefined &&
            (obj.standardStream =
                message.standardStream !== undefined
                    ? standardStreamToJSON(message.standardStream)
                    : undefined);
        message.filePath !== undefined && (obj.filePath = message.filePath);
        return obj;
    },

    fromPartial<I extends Exact<DeepPartial<LogMessage>, I>>(object: I): LogMessage {
        const message = { ...baseLogMessage } as LogMessage;
        message.content = object.content ?? Buffer.alloc(0);
        message.createdAt = object.createdAt ?? undefined;
        message.standardStream = object.standardStream ?? undefined;
        message.filePath = object.filePath ?? undefined;
        return message;
    },
};

/**
 * A set of methods for managing Project Jobs. Do not use these methods manually.
 * For working with DataSphere Jobs, install DataSphere CLI via `pip install datasphere`.
 */
export const ProjectJobServiceService = {
    /** Creates job. */
    create: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Create',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: CreateProjectJobRequest) =>
            Buffer.from(CreateProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => CreateProjectJobRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Clone job. */
    clone: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Clone',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: CloneProjectJobRequest) =>
            Buffer.from(CloneProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => CloneProjectJobRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Runs job execution. */
    execute: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Execute',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: ExecuteProjectJobRequest) =>
            Buffer.from(ExecuteProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => ExecuteProjectJobRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Cancels running job. */
    cancel: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Cancel',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: CancelProjectJobRequest) =>
            Buffer.from(CancelProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => CancelProjectJobRequest.decode(value),
        responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Empty.decode(value),
    },
    /**
     * Returns stream of job logs.
     *
     * @deprecated
     */
    readStdLogs: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/ReadStdLogs',
        requestStream: false,
        responseStream: true,
        requestSerialize: (value: ReadProjectJobStdLogsRequest) =>
            Buffer.from(ReadProjectJobStdLogsRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => ReadProjectJobStdLogsRequest.decode(value),
        responseSerialize: (value: ReadProjectJobStdLogsResponse) =>
            Buffer.from(ReadProjectJobStdLogsResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => ReadProjectJobStdLogsResponse.decode(value),
    },
    /** Returns stream of job logs. */
    readLogs: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/ReadLogs',
        requestStream: false,
        responseStream: true,
        requestSerialize: (value: ReadProjectJobLogsRequest) =>
            Buffer.from(ReadProjectJobLogsRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => ReadProjectJobLogsRequest.decode(value),
        responseSerialize: (value: ReadProjectJobLogsResponse) =>
            Buffer.from(ReadProjectJobLogsResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => ReadProjectJobLogsResponse.decode(value),
    },
    /** Returns download urls for job files. */
    downloadJobFiles: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/DownloadJobFiles',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DownloadProjectJobFilesRequest) =>
            Buffer.from(DownloadProjectJobFilesRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DownloadProjectJobFilesRequest.decode(value),
        responseSerialize: (value: DownloadProjectJobFilesResponse) =>
            Buffer.from(DownloadProjectJobFilesResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => DownloadProjectJobFilesResponse.decode(value),
    },
    /** Lists jobs. */
    list: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/List',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: ListProjectJobRequest) =>
            Buffer.from(ListProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => ListProjectJobRequest.decode(value),
        responseSerialize: (value: ListProjectJobResponse) =>
            Buffer.from(ListProjectJobResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => ListProjectJobResponse.decode(value),
    },
    /** Returns job by id. */
    get: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Get',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: GetProjectJobRequest) =>
            Buffer.from(GetProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => GetProjectJobRequest.decode(value),
        responseSerialize: (value: Job) => Buffer.from(Job.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Job.decode(value),
    },
    /** Deletes specified job. */
    delete: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/Delete',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DeleteProjectJobRequest) =>
            Buffer.from(DeleteProjectJobRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DeleteProjectJobRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Delete job data. */
    deleteData: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/DeleteData',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DeleteProjectJobDataRequest) =>
            Buffer.from(DeleteProjectJobDataRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DeleteProjectJobDataRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Delete all jobs data. */
    deleteAllData: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/DeleteAllData',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DeleteAllProjectJobDataRequest) =>
            Buffer.from(DeleteAllProjectJobDataRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DeleteAllProjectJobDataRequest.decode(value),
        responseSerialize: (value: Operation) => Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Update job data ttl. */
    setDataTtl: {
        path: '/yandex.cloud.datasphere.v2.jobs.ProjectJobService/SetDataTtl',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: SetProjectJobDataTtlRequest) =>
            Buffer.from(SetProjectJobDataTtlRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => SetProjectJobDataTtlRequest.decode(value),
        responseSerialize: (value: SetProjectJobDataTtlResponse) =>
            Buffer.from(SetProjectJobDataTtlResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => SetProjectJobDataTtlResponse.decode(value),
    },
} as const;

export interface ProjectJobServiceServer extends UntypedServiceImplementation {
    /** Creates job. */
    create: handleUnaryCall<CreateProjectJobRequest, Operation>;
    /** Clone job. */
    clone: handleUnaryCall<CloneProjectJobRequest, Operation>;
    /** Runs job execution. */
    execute: handleUnaryCall<ExecuteProjectJobRequest, Operation>;
    /** Cancels running job. */
    cancel: handleUnaryCall<CancelProjectJobRequest, Empty>;
    /**
     * Returns stream of job logs.
     *
     * @deprecated
     */
    readStdLogs: handleServerStreamingCall<
        ReadProjectJobStdLogsRequest,
        ReadProjectJobStdLogsResponse
    >;
    /** Returns stream of job logs. */
    readLogs: handleServerStreamingCall<ReadProjectJobLogsRequest, ReadProjectJobLogsResponse>;
    /** Returns download urls for job files. */
    downloadJobFiles: handleUnaryCall<
        DownloadProjectJobFilesRequest,
        DownloadProjectJobFilesResponse
    >;
    /** Lists jobs. */
    list: handleUnaryCall<ListProjectJobRequest, ListProjectJobResponse>;
    /** Returns job by id. */
    get: handleUnaryCall<GetProjectJobRequest, Job>;
    /** Deletes specified job. */
    delete: handleUnaryCall<DeleteProjectJobRequest, Operation>;
    /** Delete job data. */
    deleteData: handleUnaryCall<DeleteProjectJobDataRequest, Operation>;
    /** Delete all jobs data. */
    deleteAllData: handleUnaryCall<DeleteAllProjectJobDataRequest, Operation>;
    /** Update job data ttl. */
    setDataTtl: handleUnaryCall<SetProjectJobDataTtlRequest, SetProjectJobDataTtlResponse>;
}

export interface ProjectJobServiceClient extends Client {
    /** Creates job. */
    create(
        request: CreateProjectJobRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    create(
        request: CreateProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    create(
        request: CreateProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Clone job. */
    clone(
        request: CloneProjectJobRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    clone(
        request: CloneProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    clone(
        request: CloneProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Runs job execution. */
    execute(
        request: ExecuteProjectJobRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    execute(
        request: ExecuteProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    execute(
        request: ExecuteProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Cancels running job. */
    cancel(
        request: CancelProjectJobRequest,
        callback: (error: ServiceError | null, response: Empty) => void,
    ): ClientUnaryCall;
    cancel(
        request: CancelProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Empty) => void,
    ): ClientUnaryCall;
    cancel(
        request: CancelProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Empty) => void,
    ): ClientUnaryCall;
    /**
     * Returns stream of job logs.
     *
     * @deprecated
     */
    readStdLogs(
        request: ReadProjectJobStdLogsRequest,
        options?: Partial<CallOptions>,
    ): ClientReadableStream<ReadProjectJobStdLogsResponse>;
    readStdLogs(
        request: ReadProjectJobStdLogsRequest,
        metadata?: Metadata,
        options?: Partial<CallOptions>,
    ): ClientReadableStream<ReadProjectJobStdLogsResponse>;
    /** Returns stream of job logs. */
    readLogs(
        request: ReadProjectJobLogsRequest,
        options?: Partial<CallOptions>,
    ): ClientReadableStream<ReadProjectJobLogsResponse>;
    readLogs(
        request: ReadProjectJobLogsRequest,
        metadata?: Metadata,
        options?: Partial<CallOptions>,
    ): ClientReadableStream<ReadProjectJobLogsResponse>;
    /** Returns download urls for job files. */
    downloadJobFiles(
        request: DownloadProjectJobFilesRequest,
        callback: (error: ServiceError | null, response: DownloadProjectJobFilesResponse) => void,
    ): ClientUnaryCall;
    downloadJobFiles(
        request: DownloadProjectJobFilesRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: DownloadProjectJobFilesResponse) => void,
    ): ClientUnaryCall;
    downloadJobFiles(
        request: DownloadProjectJobFilesRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: DownloadProjectJobFilesResponse) => void,
    ): ClientUnaryCall;
    /** Lists jobs. */
    list(
        request: ListProjectJobRequest,
        callback: (error: ServiceError | null, response: ListProjectJobResponse) => void,
    ): ClientUnaryCall;
    list(
        request: ListProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: ListProjectJobResponse) => void,
    ): ClientUnaryCall;
    list(
        request: ListProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: ListProjectJobResponse) => void,
    ): ClientUnaryCall;
    /** Returns job by id. */
    get(
        request: GetProjectJobRequest,
        callback: (error: ServiceError | null, response: Job) => void,
    ): ClientUnaryCall;
    get(
        request: GetProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Job) => void,
    ): ClientUnaryCall;
    get(
        request: GetProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Job) => void,
    ): ClientUnaryCall;
    /** Deletes specified job. */
    delete(
        request: DeleteProjectJobRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    delete(
        request: DeleteProjectJobRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    delete(
        request: DeleteProjectJobRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Delete job data. */
    deleteData(
        request: DeleteProjectJobDataRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    deleteData(
        request: DeleteProjectJobDataRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    deleteData(
        request: DeleteProjectJobDataRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Delete all jobs data. */
    deleteAllData(
        request: DeleteAllProjectJobDataRequest,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    deleteAllData(
        request: DeleteAllProjectJobDataRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    deleteAllData(
        request: DeleteAllProjectJobDataRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void,
    ): ClientUnaryCall;
    /** Update job data ttl. */
    setDataTtl(
        request: SetProjectJobDataTtlRequest,
        callback: (error: ServiceError | null, response: SetProjectJobDataTtlResponse) => void,
    ): ClientUnaryCall;
    setDataTtl(
        request: SetProjectJobDataTtlRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: SetProjectJobDataTtlResponse) => void,
    ): ClientUnaryCall;
    setDataTtl(
        request: SetProjectJobDataTtlRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: SetProjectJobDataTtlResponse) => void,
    ): ClientUnaryCall;
}

export const ProjectJobServiceClient = makeGenericClientConstructor(
    ProjectJobServiceService,
    'yandex.cloud.datasphere.v2.jobs.ProjectJobService',
) as unknown as {
    new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ChannelOptions>,
    ): ProjectJobServiceClient;
    service: typeof ProjectJobServiceService;
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
    if (typeof globalThis !== 'undefined') return globalThis;
    if (typeof self !== 'undefined') return self;
    if (typeof window !== 'undefined') return window;
    if (typeof global !== 'undefined') return global;
    throw 'Unable to locate global object';
})();

const atob: (b64: string) => string =
    globalThis.atob || ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64: string): Uint8Array {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}

const btoa: (bin: string) => string =
    globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr: Uint8Array): string {
    const bin: string[] = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends Array<infer U>
    ? Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;

function toTimestamp(date: Date): Timestamp {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
    let millis = t.seconds * 1_000;
    millis += t.nanos / 1_000_000;
    return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
    if (o instanceof Date) {
        return o;
    } else if (typeof o === 'string') {
        return new Date(o);
    } else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}

function longToNumber(long: Long): number {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}

if (_m0.util.Long !== Long) {
    _m0.util.Long = Long as any;
    _m0.configure();
}
